<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>配置重构</title>
      <link href="/2019/04/22/%E9%85%8D%E7%BD%AE%E9%87%8D%E6%9E%84/"/>
      <url>/2019/04/22/%E9%85%8D%E7%BD%AE%E9%87%8D%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<!--toc--><p>本文对配置重构的优缺点进行总结，对配置重构产生的价值进行梳理。<br><a id="more"></a></p><h2><span id="背景">背景</span></h2><p>原来在融汇一代的配置是以<code>XML</code>格式存放在程序的<code>config</code>目录下。大多数程序都有企业配置、银行配置、以及其他的业务相关配置。所有的银行配置都存放在<code>BankConfig.xml</code>中，所有企业配置存放在<code>SubScriConfig.xml</code>。而随着银行渠道增多，企业越来越多，业务复杂性提升。目前的配置已经不便于运维维护，也不再适应于微服务的架构,配置升级刻不容缓。</p><h2><span id="重构的价值">重构的价值</span></h2><p>目前融汇二代处于研发阶段，主要还是依赖于融汇一代的业务支持，而融汇依赖原来的架构并未考虑到运维的可维护性，造成程序配置，程序部署，程序迁移的的工作量极大。而对于后期规划来说，无论使融汇一代还是融汇二代，都会往微服务架构方向发展。</p><p><img src="//guojielin.github.io/2019/04/22/配置重构/2019-04-22-11-48-40.png" alt="2019-04-22-11-48-40.png"></p><h3><span id="适用于微服务架构">适用于微服务架构</span></h3><p>微服务架构具有可扩展性，独立性，原来的配置方式不再适用与微服务架构。主要原因是原来每个程序会有一份配置文件，甚至每份配置文件可能还不一样。这样的配置的方式对企业迁移造成了极大的困难，对于运维维护上造成大量的重复工作量，且极易改错或改漏配置。因为配置作为最重要的基础项之一必须优先优化。</p><h3><span id="跨平台">跨平台</span></h3><p>微服务架构，通过统一的接口调用，即可实现多平台互联互通。每个平台都有自己的技术优势，通过服务调用可以屏蔽不同平台的语言差异，环境差异。合理的利用不同平台的优势。</p><blockquote><p>这里所说的平台指的是技术平台，如<code>.net</code>、<code>java</code>或其他平台等。</p></blockquote><h3><span id="自动化">自动化</span></h3><p>目前二代已经开始使用自动化部署，而一代也已经在进行自动化的建设及试用。通过配置重构以后，充分的考虑到自动化的需求。最终实现一键部署，一键升级的能力。这其中都需要极为扎实的基础框架建设。</p><h3><span id="动态迁移和扩容">动态迁移和扩容</span></h3><p>在微服务的架构之上实现服务的高可用后，服务动态扩容和动态迁移的即可实现。程序和本地配置已经剥离开来，迁移程序无需在迁移配置或缓存信息。极大的降低了运维工作量。</p><h3><span id="终极价值">终极价值</span></h3><p>搭建运维平台，降低配置管理工作量，降低程序升级和程序部署的工作量。</p><ul><li>配置管理，因为只保存了一份配置，因此更为容易的进行配置维护。</li><li>服务管理，通过在持续集成和持续部署的基础之上，可视化进行服务管理。包括服务关闭、服务启动、服务重启、服务升级、服务回退等。同时也为服务部署、服务迁移和服务扩容提供了基础。通过“一键”部署，“一键”迁移极大的减轻当前运维人员碰到的所有痛点和难点。</li></ul><h2><span id="如何重构">如何重构</span></h2><h3><span id="方案一">方案一</span></h3><p>依然以xml格式存储，将之前的配置按银行和企业将对应的配置拆分到不同文件。好处是部分配置节点依然可以使用，降低运维首次更新配置的工作量。将配置拆分到多个配置文件，更便于配置查找和修改。支持重载配置(企业配置配置覆盖公共配置)，减少公共配置量。通过SVN方式托管配置，有一个统一的配置数据源，也适用于微服务架构。</p><h3><span id="方案二">方案二</span></h3><p>目前二代是将配置存储到数据库。可以延用二代的方案，好处是可以做到一二代配置通用，同时在初期运维可以通过数据库对数据进行增删查改。相比直接修改文本文件，更为方便一些。同时也适用于微服务架构。二代目前已经有了界面化配置，可以直接使用二代的界面化配置进行配置修改，而一代加载数据即可。</p>]]></content>
      
      
      <categories>
          
          <category> 基础设施 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础设施 </tag>
            
            <tag> 重构 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发流程测试环境部署规范</title>
      <link href="/2019/04/17/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E8%A7%84%E8%8C%83/"/>
      <url>/2019/04/17/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows版本redis高可用方案探究</title>
      <link href="/2019/04/16/Windows%E7%89%88%E6%9C%ACredis%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88%E6%8E%A2%E7%A9%B6/"/>
      <url>/2019/04/16/Windows%E7%89%88%E6%9C%ACredis%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h2><span id="toc">[TOC]</span></h2><h1><span id="windows版本redis高可用方案探究">Windows版本redis高可用方案探究</span></h1><h2><span id="前言">前言</span></h2><p>本篇文章专注于讲解redis在windows环境下使用Redis Sentinel(哨兵)实现高可用方案。</p><p>想要在windows环境下实现redis高可用，先要准备以下材料或知识点。</p><ol><li>redis 3.2.100<br>目前在windows版本最新的redis是3.2.100，可以到<a href="https://github.com/MicrosoftArchive/redis/tags" target="_blank" rel="noopener">这里</a>下载</li><li>Redis Sentinel<br>redis本身不支持高可用方案，通过sentinel对redis进行监控及动态调节等。</li></ol><h2><span id="搭建redis主从">搭建redis主从</span></h2><p>下载的压缩文件内容如下图所示。<br><img src="//img2018.cnblogs.com/blog/580757/201901/580757-20190105093939573-1127915260.png" alt="1.png"><br>具体结构如下图所示<br><img src="https://img2018.cnblogs.com/blog/580757/201901/580757-20190105095630588-1910152801.png" alt="2.png"></p><p>应用层连接redis集群，集群包括3个redis服务(1主2从)和3个哨兵。</p><blockquote><p>哨兵用于监控主redis可用性。若长时间不可用，则哨兵进行投票选举出新的主redis。原来的主redis降级为从redis。哨兵会将所有redis的配置进行自动更新。</p></blockquote><h3><span id="配置主redis-28380">配置主redis-28380</span></h3><p>将redis复制一份。一个文件夹用于部署redis服务，一个文件夹用于部署哨兵。<br><img src="https://img2018.cnblogs.com/blog/580757/201901/580757-20190105094347764-1883677257.png" alt="3.png"></p><p>规定redis服务端口为28380~28382。将redis.windiws-service.config改名为redis-28380.conf。打开进行修改。</p><ol><li>修改绑定端口<br>注释掉<code>bind 127.0.0.1</code>,默认为监听所有ip。</li><li>将保护模式关闭<br>修改<code>protected-mode yes</code>为<code>protected-mode no</code>，默认redis开启了保护模式，只允许本机通过127.0.0.1访问，其他ip无法访问。</li><li>修改监听端口<br>修改<code>port 6379</code>为<code>port 28380</code></li><li>修改日志等级<br>修改<code>loglevel debug</code>为<code>loglevel notice</code></li><li>修改日志文件名<br>修改<code>logfile &quot;server_log.txt&quot;</code>为<code>logfile &quot;server_log_28380.txt&quot;</code></li><li>修改windows日志的事件名<br>修改<code>syslog-ident redis</code>为<code>syslog-ident &quot;redis-28380&quot;</code></li><li><p>修改不保存rdb文件<br>注释掉一下三行，由于rdb会每次全量写文件，当数据量较大时会对redis稳定性造成一定影响，尤其是rbd保存失败时会一定时间内拒绝写入数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure></li><li><p>创建密码<br>修改<code># requirepass foobared</code>为<code>requirepass &quot;test1&quot;</code><br>新增<code>masterauth &quot;test1&quot;</code></p><blockquote><p>若要设置密码，单台redis设置<code>requirepass</code>即可。集群redis必须同时设置<code>requirepass</code>和<code>masterauth</code>。若主redis没有设置<code>masterauth</code>当它变为从时，就认为主无密码。若从redis没有设置<code>requirepass</code>，当它变为主时，会没有密码。以上两种情况自动切换都无法自动连接到新的主。</p></blockquote></li><li><p>启用aof保存<br>修改<code>appendonly no</code>为<code>appendonly yes</code><br>修改<code>appendfilename &quot;appendonly.aof&quot;</code>为<code>appendfilename &quot;appendonly_28380.aof&quot;</code></p><blockquote><p>aof写入的是redis命令，每次向文件后面添加，因此对IO性能影响较小。最坏情况主redis丢失1s的数据。</p></blockquote></li></ol><p>配置改好后保存，这个当作主redis的配置。将改配置复制2份，分别改名为redis-28381.conf和redis-28382.conf</p><h3><span id="配置从redis-23381">配置从redis-23381</span></h3><ol><li>修改监听端口<br>修改<code>port 28380</code>为<code>port 28381</code></li><li>修改日志文件名<br>修改<code>logfile &quot;server_log-28380.txt&quot;</code>为<code>logfile &quot;server_log_28381.txt&quot;</code> </li><li>修改windows日志的事件名<br>修改<code>syslog-ident &quot;redis-28380&quot;</code>为<code>syslog-ident &quot;redis-28381&quot;</code>  </li><li>修改从库对应的主库ip<br>修改<code># slaveof &lt;masterip&gt; &lt;masterport&gt;</code>为<code>slaveof 127.0.0.1 28380</code> <blockquote><p>23880做为主库，填写的就是28380的端口</p></blockquote></li><li>修改从库竞选主库优先级<br>修改<code>slave-priority 100</code>为<code>slave-priority 99</code><blockquote><p>将每个从库设置为不通的优先级，数字较低的优先被竞选为主库。</p></blockquote></li><li>修改aof保存的文件名<br>修改<code>appendfilename &quot;appendonly_28380.aof&quot;</code>为<code>appendfilename &quot;appendonly_28381.aof&quot;</code></li></ol><h3><span id="配置从redis-23382">配置从redis-23382</span></h3><ol><li>修改监听端口<br>修改<code>port 28380</code>为<code>port 28382</code></li><li>修改日志文件名<br>修改<code>logfile &quot;server_log-28380.txt&quot;</code>为<code>logfile &quot;server_log_28382.txt&quot;</code> </li><li>修改windows日志的事件名<br>修改<code>syslog-ident &quot;redis-28380&quot;</code>为<code>syslog-ident &quot;redis-28382&quot;</code>  </li><li>修改从库对应的主库ip<br>修改<code># slaveof &lt;masterip&gt; &lt;masterport&gt;</code>为<code>slaveof 127.0.0.1 28380</code> <blockquote><p>23880做为主库，填写的就是28380的端口</p></blockquote></li><li>修改从库竞选主库优先级<br>修改<code>slave-priority 100</code>为<code>slave-priority 98</code><blockquote><p>将每个从库设置为不通的优先级，数字较低的优先被竞选为主库。</p></blockquote></li><li>修改aof保存的文件名<br>修改<code>appendfilename &quot;appendonly_28380.aof&quot;</code>为<code>appendfilename &quot;appendonly_28382.aof&quot;</code></li></ol><h3><span id="将redis部署为服务">将redis部署为服务</span></h3><p>通过命令<code>redis-server --service-install 配置名 --service-name 服务名</code> 将redis安装为服务。<br>先cd到redis所在目录，在cmd命令行中输入一下三条语句将三个redis安装成功为windows服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server --service-install redis-28380.conf --service-name redis-28380</span><br><span class="line">redis-server --service-install redis-28381.conf --service-name redis-28381</span><br><span class="line">redis-server --service-install redis-28382.conf --service-name redis-28382</span><br></pre></td></tr></table></figure><blockquote><p>设置服务别名是为了在服务中能更好的看到哪个是哪个服务，否则默认都是redis服务。</p></blockquote><p><img src="https://img2018.cnblogs.com/blog/580757/201901/580757-20190105111922318-585143415.png" alt="4.png"></p><h3><span id="启动redis">启动redis</span></h3><p>可以直接在服务中右键启动或者通过命令<code>redis-server --service-start --service-name 服务名</code> 启动指定服务。</p><p>通过redis-cli 连接到各个redis服务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">F:\Study\redis&gt; redis-cli -p 28380 -a test1</span><br><span class="line">127.0.0.1:28380&gt; info Replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=28382,state=online,offset=183,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=28381,state=online,offset=183,lag=1</span><br><span class="line">master_repl_offset:183</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:182</span><br></pre></td></tr></table></figure></p><p>可以看到我们的主从配置已经生效了。</p><p>连接到从库28381<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">F:\Study\redis&gt;  redis-cli -p 28381 -a test1</span><br><span class="line">127.0.0.1:28381&gt;  info Replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:28380</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:9</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:323</span><br><span class="line">slave_priority:99</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure></p><p>连接到从库28382<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">F:\Study\redis&gt;  redis-cli -p 28382 -a test1</span><br><span class="line">127.0.0.1:28382&gt; info Replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:28380</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:8</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:379</span><br><span class="line">slave_priority:99</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure></p><p>现在我们往主库写入数据会自动并主动同步到从库。</p><blockquote><p>配置中默认配了以下配置了<code>slave-read-only yes</code>,从库是只读的，不允许写入。</p></blockquote><h2><span id="配置哨兵">配置哨兵</span></h2><p>设置三个哨兵端口为 24381~24383</p><p>配置哨兵24381<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dir ./</span><br><span class="line">logfile &quot;sentinel.28481.txt&quot;</span><br><span class="line">port 28481</span><br><span class="line">sentinel monitor master 127.0.0.1 28380 2</span><br><span class="line">sentinel down-after-milliseconds master 5000</span><br><span class="line">sentinel failover-timeout master 30000</span><br><span class="line">sentinel auth-pass 127.0.0.1 28380 test1</span><br></pre></td></tr></table></figure></p><ul><li><code>sentinel monitor master 127.0.0.1 28380 2</code> 设置主redis的别名为master，后面都通过master表示主redis。后面的2表示2个哨兵检测到主redis挂了即为挂了，需要重新选举出新的主redis，而原来的主redis降级为从redis。</li><li><code>sentinel down-after-milliseconds master 5000</code> 哨兵多久连不上主redis即认为它挂了</li><li><p><code>sentinel failover-timeout master 30000</code> 投票选举超时时间，超过时间没有选出则该轮投票失败。</p></li><li><p><code>sentinel auth-pass master test1</code> 主redis的密码 。</p></li></ul><blockquote><p>由于哨兵只能设置主的密码，因此主从的密码应该设置为一样的。</p></blockquote><p>配置哨兵24382<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dir ./</span><br><span class="line">logfile &quot;sentinel.28482.txt&quot;</span><br><span class="line">port 28482</span><br><span class="line">sentinel monitor master 127.0.0.1 28380 2</span><br><span class="line">sentinel down-after-milliseconds master 5000</span><br><span class="line">sentinel failover-timeout master 30000</span><br><span class="line">sentinel auth-pass 127.0.0.1 28380 test1</span><br></pre></td></tr></table></figure></p><p>配置哨兵24383<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dir ./</span><br><span class="line">logfile &quot;sentinel.28483.txt&quot;</span><br><span class="line">port 28483</span><br><span class="line">sentinel monitor master 127.0.0.1 28380 2</span><br><span class="line">sentinel down-after-milliseconds master 5000</span><br><span class="line">sentinel failover-timeout master 30000</span><br><span class="line">sentinel auth-pass 127.0.0.1 28380 test1</span><br></pre></td></tr></table></figure></p><h3><span id="启动哨兵">启动哨兵</span></h3><p>通过命令<code>redis-server.exe 配置 --sentinel</code> 启动哨兵</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-sentinel-28481.conf --sentinel</span><br><span class="line">redis-server redis-sentinel-28482.conf --sentinel</span><br><span class="line">redis-server redis-sentinel-28483.conf --sentinel</span><br></pre></td></tr></table></figure><p>启动哨兵28481后查看日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[8464] 21 Nov 02:02:05.258 # +tilt #tilt mode entered</span><br><span class="line">[8464] 21 Nov 08:33:01.513 # +tilt #tilt mode entered</span><br><span class="line">[8464] 21 Nov 08:33:31.561 # -tilt #tilt mode exited</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ &apos;&apos;-._                                             </span><br><span class="line">      _.-``    `.  `_.  &apos;&apos;-._           Redis 3.2.100 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ &apos;&apos;-._                                   </span><br><span class="line"> (    &apos;      ,       .-`  | `,    )     Running in sentinel mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|&apos;` _.-&apos;|     Port: 28481</span><br><span class="line"> |    `-._   `._    /     _.-&apos;    |     PID: 22332</span><br><span class="line">  `-._    `-._  `-./  _.-&apos;    _.-&apos;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  </span><br><span class="line"> |    `-._`-._        _.-&apos;_.-&apos;    |           http://redis.io        </span><br><span class="line">  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   </span><br><span class="line"> |`-._`-._    `-.__.-&apos;    _.-&apos;_.-&apos;|                                  </span><br><span class="line"> |    `-._`-._        _.-&apos;_.-&apos;    |                                  </span><br><span class="line">  `-._    `-._`-.__.-&apos;_.-&apos;    _.-&apos;                                   </span><br><span class="line">      `-._    `-.__.-&apos;    _.-&apos;                                       </span><br><span class="line">          `-._        _.-&apos;                                           </span><br><span class="line">              `-.__.-&apos;                                               </span><br><span class="line"></span><br><span class="line">[22332] 05 Jan 12:01:48.399 # Sentinel ID is 48693b2911456ef3da6ebfd14d1adf46e76fbb8b</span><br><span class="line">[22332] 05 Jan 12:01:48.399 # +monitor master master 127.0.0.1 28382 quorum 2</span><br><span class="line">[22332] 05 Jan 12:01:53.399 # +sdown sentinel ce50397a76e2e3ca165ce407859cbc94d7caf504 127.0.0.1 28482 @ master 127.0.0.1 28382</span><br><span class="line">[22332] 05 Jan 12:01:53.399 # +sdown sentinel 162c66f370550a9926b794abecfb431cf3f8bcc9 127.0.0.1 28483 @ master 127.0.0.1 28382</span><br><span class="line">[22332] 05 Jan 12:02:13.404 # +sdown master master 127.0.0.1 28382</span><br></pre></td></tr></table></figure></p><p>同时启动完会自动在哨兵的配置文件中生成一些配置,完整的redis-sentinel-28481.conf配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dir &quot;F:\\Study\\redis\\redis-sentinel&quot;</span><br><span class="line">logfile &quot;sentinel.28481.txt&quot;</span><br><span class="line">port 28481</span><br><span class="line">sentinel myid 48693b2911456ef3da6ebfd14d1adf46e76fbb8b</span><br><span class="line">sentinel monitor master 127.0.0.1 28381 2</span><br><span class="line">sentinel down-after-milliseconds master 5000</span><br><span class="line">sentinel failover-timeout master 30000</span><br><span class="line"># Generated by CONFIG REWRITE</span><br><span class="line">sentinel auth-pass master test1</span><br><span class="line">sentinel config-epoch master 11</span><br><span class="line">sentinel leader-epoch master 11</span><br><span class="line">sentinel known-slave master 127.0.0.1 28382</span><br><span class="line">sentinel known-slave master 127.0.0.1 28380</span><br><span class="line">sentinel known-sentinel master 127.0.0.1 28482 ce50397a76e2e3ca165ce407859cbc94d7caf504</span><br><span class="line">sentinel known-sentinel master 127.0.0.1 28483 162c66f370550a9926b794abecfb431cf3f8bcc9</span><br><span class="line">sentinel current-epoch 11</span><br></pre></td></tr></table></figure></p><p>启动后会为哨兵生成一个id，同时会记录一些关键信息。</p><h3><span id="主从自动切换">主从自动切换</span></h3><p>将主redis关闭，让哨兵自动切换主从。<br>哨兵24381日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[22332] 05 Jan 12:34:49.286 # +sdown master master 127.0.0.1 28380</span><br><span class="line">[22332] 05 Jan 12:34:49.295 # +new-epoch 16</span><br><span class="line">[22332] 05 Jan 12:34:49.296 # +vote-for-leader ce50397a76e2e3ca165ce407859cbc94d7caf504 16</span><br><span class="line">[22332] 05 Jan 12:34:49.363 # +odown master master 127.0.0.1 28380 #quorum 3/2</span><br><span class="line">[22332] 05 Jan 12:34:49.363 # Next failover delay: I will not start a failover before Sat Jan 05 12:35:49 2019</span><br><span class="line">[22332] 05 Jan 12:34:50.397 # +config-update-from sentinel ce50397a76e2e3ca165ce407859cbc94d7caf504 127.0.0.1 28482 @ master 127.0.0.1 28380</span><br><span class="line">[22332] 05 Jan 12:34:50.397 # +switch-master master 127.0.0.1 28380 127.0.0.1 28382</span><br><span class="line">[22332] 05 Jan 12:34:50.397 * +slave slave 127.0.0.1:28381 127.0.0.1 28381 @ master 127.0.0.1 28382</span><br><span class="line">[22332] 05 Jan 12:34:50.397 * +slave slave 127.0.0.1:28380 127.0.0.1 28380 @ master 127.0.0.1 28382</span><br><span class="line">[22332] 05 Jan 12:34:55.442 # +sdown slave 127.0.0.1:28380 127.0.0.1 28380 @ master 127.0.0.1 28382</span><br></pre></td></tr></table></figure></p><p>哨兵24382日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[8760] 05 Jan 12:34:49.237 # +sdown master master 127.0.0.1 28380</span><br><span class="line">[8760] 05 Jan 12:34:49.292 # +odown master master 127.0.0.1 28380 #quorum 2/2</span><br><span class="line">[8760] 05 Jan 12:34:49.292 # +new-epoch 16</span><br><span class="line">[8760] 05 Jan 12:34:49.292 # +try-failover master master 127.0.0.1 28380</span><br><span class="line">[8760] 05 Jan 12:34:49.293 # +vote-for-leader ce50397a76e2e3ca165ce407859cbc94d7caf504 16</span><br><span class="line">[8760] 05 Jan 12:34:49.296 # 162c66f370550a9926b794abecfb431cf3f8bcc9 voted for ce50397a76e2e3ca165ce407859cbc94d7caf504 16</span><br><span class="line">[8760] 05 Jan 12:34:49.296 # 48693b2911456ef3da6ebfd14d1adf46e76fbb8b voted for ce50397a76e2e3ca165ce407859cbc94d7caf504 16</span><br><span class="line">[8760] 05 Jan 12:34:49.394 # +elected-leader master master 127.0.0.1 28380</span><br><span class="line">[8760] 05 Jan 12:34:49.394 # +failover-state-select-slave master master 127.0.0.1 28380</span><br><span class="line">[8760] 05 Jan 12:34:49.470 # +selected-slave slave 127.0.0.1:28382 127.0.0.1 28382 @ master 127.0.0.1 28380</span><br><span class="line">[8760] 05 Jan 12:34:49.470 * +failover-state-send-slaveof-noone slave 127.0.0.1:28382 127.0.0.1 28382 @ master 127.0.0.1 28380</span><br><span class="line">[8760] 05 Jan 12:34:49.541 * +failover-state-wait-promotion slave 127.0.0.1:28382 127.0.0.1 28382 @ master 127.0.0.1 28380</span><br><span class="line">[8760] 05 Jan 12:34:50.341 # +promoted-slave slave 127.0.0.1:28382 127.0.0.1 28382 @ master 127.0.0.1 28380</span><br><span class="line">[8760] 05 Jan 12:34:50.341 # +failover-state-reconf-slaves master master 127.0.0.1 28380</span><br><span class="line">[8760] 05 Jan 12:34:50.396 * +slave-reconf-sent slave 127.0.0.1:28381 127.0.0.1 28381 @ master 127.0.0.1 28380</span><br><span class="line">[8760] 05 Jan 12:34:51.380 * +slave-reconf-inprog slave 127.0.0.1:28381 127.0.0.1 28381 @ master 127.0.0.1 28380</span><br><span class="line">[8760] 05 Jan 12:34:51.446 # -odown master master 127.0.0.1 28380</span><br><span class="line">[8760] 05 Jan 12:34:52.393 * +slave-reconf-done slave 127.0.0.1:28381 127.0.0.1 28381 @ master 127.0.0.1 28380</span><br><span class="line">[8760] 05 Jan 12:34:52.468 # +failover-end master master 127.0.0.1 28380</span><br><span class="line">[8760] 05 Jan 12:34:52.468 # +switch-master master 127.0.0.1 28380 127.0.0.1 28382</span><br><span class="line">[8760] 05 Jan 12:34:52.469 * +slave slave 127.0.0.1:28381 127.0.0.1 28381 @ master 127.0.0.1 28382</span><br><span class="line">[8760] 05 Jan 12:34:52.469 * +slave slave 127.0.0.1:28380 127.0.0.1 28380 @ master 127.0.0.1 28382</span><br><span class="line">[8760] 05 Jan 12:34:57.562 # +sdown slave 127.0.0.1:28380 127.0.0.1 28380 @ master 127.0.0.1 28382</span><br></pre></td></tr></table></figure></p><p>哨兵24383日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[26484] 05 Jan 12:34:49.161 # +sdown master master 127.0.0.1 28380</span><br><span class="line">[26484] 05 Jan 12:34:49.294 # +new-epoch 16</span><br><span class="line">[26484] 05 Jan 12:34:49.295 # +vote-for-leader ce50397a76e2e3ca165ce407859cbc94d7caf504 16</span><br><span class="line">[26484] 05 Jan 12:34:50.284 # +odown master master 127.0.0.1 28380 #quorum 3/2</span><br><span class="line">[26484] 05 Jan 12:34:50.284 # Next failover delay: I will not start a failover before Sat Jan 05 12:35:49 2019</span><br><span class="line">[26484] 05 Jan 12:34:50.397 # +config-update-from sentinel ce50397a76e2e3ca165ce407859cbc94d7caf504 127.0.0.1 28482 @ master 127.0.0.1 28380</span><br><span class="line">[26484] 05 Jan 12:34:50.397 # +switch-master master 127.0.0.1 28380 127.0.0.1 28382</span><br><span class="line">[26484] 05 Jan 12:34:50.397 * +slave slave 127.0.0.1:28381 127.0.0.1 28381 @ master 127.0.0.1 28382</span><br><span class="line">[26484] 05 Jan 12:34:50.397 * +slave slave 127.0.0.1:28380 127.0.0.1 28380 @ master 127.0.0.1 28382</span><br><span class="line">[26484] 05 Jan 12:34:55.437 # +sdown slave 127.0.0.1:28380 127.0.0.1 28380 @ master 127.0.0.1 28382</span><br></pre></td></tr></table></figure></p><p>具体投票过程这里不做具体分析。<br>当选出新的主redis，哨兵会对redis配置进行更新，将主redis的<code>slaveof XXX XXX</code>配置删除，将从的<code>slaveof XXX XXX</code>设置为主的地址。同时哨兵会监控redis28380。当28380恢复后会将<code>slaveof XXX XXX</code>添加到它的配置中。</p><p>连接到28382查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:28382&gt; info Replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=28381,state=online,offset=193307,lag=1</span><br><span class="line">slave1:ip=127.0.0.1,port=28380,state=online,offset=193441,lag=1</span><br><span class="line">master_repl_offset:193575</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:193574</span><br></pre></td></tr></table></figure></p><h3><span id="动态新增从库">动态新增从库</span></h3><p>若我们此时动态新增一个从redis，端口为28383，则复制一个28380的配置进行修改,将优先级改为97。并启动服务即可。</p><p>redis-28383日志如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[14048] 05 Jan 12:55:20.421 * Redis 3.2.100 (00000000/0) 64 bit, standalone mode, port 28383, pid 14048 ready to start.</span><br><span class="line">[14048] 05 Jan 12:55:20.422 # Server started, Redis version 3.2.100</span><br><span class="line">[14048] 05 Jan 12:55:20.423 * The server is now ready to accept connections on port 28383</span><br><span class="line">[14048] 05 Jan 12:55:20.424 * Connecting to MASTER 127.0.0.1:28382</span><br><span class="line">[14048] 05 Jan 12:55:20.426 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line">[14048] 05 Jan 12:55:20.427 * Non blocking connect for SYNC fired the event.</span><br><span class="line">[14048] 05 Jan 12:55:20.428 * Master replied to PING, replication can continue...</span><br><span class="line">[14048] 05 Jan 12:55:20.428 * Partial resynchronization not possible (no cached master)</span><br><span class="line">[14048] 05 Jan 12:55:20.432 * Full resync from master: 2c344529e4acdc44cd311818fe8179825877a9f4:241347</span><br><span class="line">[14048] 05 Jan 12:55:20.653 * MASTER &lt;-&gt; SLAVE sync: receiving 107 bytes from master</span><br><span class="line">[14048] 05 Jan 12:55:20.655 * MASTER &lt;-&gt; SLAVE sync: Flushing old data</span><br><span class="line">[14048] 05 Jan 12:55:20.655 * MASTER &lt;-&gt; SLAVE sync: Loading DB in memory</span><br><span class="line">[14048] 05 Jan 12:55:20.656 * MASTER &lt;-&gt; SLAVE sync: Finished with success</span><br><span class="line">[14048] 05 Jan 12:55:20.660 * Background append only file rewriting started by pid 29392</span><br><span class="line">[14048] 05 Jan 12:55:20.827 * AOF rewrite child asks to stop sending diffs.</span><br><span class="line">[14048] 05 Jan 12:55:20.927 # fork operation complete</span><br><span class="line">[14048] 05 Jan 12:55:20.928 * Background AOF rewrite terminated with success</span><br><span class="line">[14048] 05 Jan 12:55:20.929 * Residual parent diff successfully flushed to the rewritten AOF (0.00 MB)</span><br><span class="line">[14048] 05 Jan 12:55:20.931 * Background AOF rewrite finished successfully</span><br></pre></td></tr></table></figure></p><p>再看下28382的主从连接信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:28382&gt; info Replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:3</span><br><span class="line">slave0:ip=127.0.0.1,port=28381,state=online,offset=268634,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=28380,state=online,offset=268768,lag=0</span><br><span class="line">slave2:ip=127.0.0.1,port=28383,state=online,offset=268634,lag=0</span><br><span class="line">master_repl_offset:268768</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:268767</span><br></pre></td></tr></table></figure><p>哨兵也能检测到新的从库连接<br><code>[22332] 05 Jan 12:55:25.420 * +slave slave 127.0.0.1:28383 127.0.0.1 28383 @ master 127.0.0.1 28382</code></p><p>通过上述配置，就完成了redis高可用方案。</p><h2><span id="程序连接redis高可用">程序连接redis高可用</span></h2><p>我使用的是<code>StackExchange.Redis</code>连接redis。</p><p>它本身就支持主从连接，在建立连接的时候输入多个连接地址接口。由于从库不允许写入。因此它能辨别出哪个是主哪个是从。主从切换后写入数据的时候重新判定哪个是主库。</p><ol><li><p>通过代码设置redis地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConfigurationOptions options = ConfigurationOptions.Parse(&quot;password=test1&quot;);</span><br><span class="line">options.EndPoints.Add(&quot;127.0.0.1&quot;, 28380);</span><br><span class="line">options.EndPoints.Add(&quot;127.0.0.1&quot;, 28381);</span><br><span class="line">options.EndPoints.Add(&quot;127.0.0.1&quot;, 28382);</span><br></pre></td></tr></table></figure></li><li><p>通过配置字符串设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigurationOptions options = ConfigurationOptions.Parse(&quot;127.0.0.1:28380,127.0.0.1:28381,127.0.0.1:28382,keepAlive=5,password=test1&quot;);</span><br></pre></td></tr></table></figure></li></ol><h2><span id="总结">总结</span></h2><p>通过该篇文章详细的探究了window下的redis高可用方案如何实现。本文对具体配置没有做深入探究，仅仅为了抓住重点，具体配置其他的文档都介绍的比较详细，但是一些细节并没有说明，通过该片文章将reids高可用的坑都填满。若有错误，欢迎指正。</p><p>实例可以从<a href="https://files.cnblogs.com/files/Jack-Blog/redis%E9%AB%98%E5%8F%AF%E7%94%A8.rar" target="_blank" rel="noopener">这里</a>下载</p><hr><h2><span id="参考文档">参考文档</span></h2><ol><li><a href="https://blog.csdn.net/csdnlyu/article/details/78738832" target="_blank" rel="noopener">redis sentinel配置（windows环境）</a></li><li><a href="https://www.cnblogs.com/zhoujinyi/p/5570024.html" target="_blank" rel="noopener">Redis 复制、Sentinel的搭建和原理说明</a></li></ol><hr><blockquote><p>本文地址：<a href="https://www.cnblogs.com/Jack-Blog/p/10224193.html" target="_blank" rel="noopener">https://www.cnblogs.com/Jack-Blog/p/10224193.html</a><br>作者博客：杰哥很忙<br>欢迎转载，请在明显位置给出出处及链接</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 高可用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试环境发布规范V0.1</title>
      <link href="/2019/04/08/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E5%8F%91%E5%B8%83%E8%A7%84%E8%8C%83/"/>
      <url>/2019/04/08/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E5%8F%91%E5%B8%83%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>关于测试环境持续集成和持续部署流程规范说明。<br><a id="more"></a></p><!-- toc --><ul><li><a href="#持续集成流程">持续集成流程</a></li><li><a href="#持续部署流程">持续部署流程</a></li><li><a href="#测试环境发布测试流程">测试环境发布测试流程</a><ul><li><a href="#原始流程">原始流程</a></li><li><a href="#自动化流程">自动化流程</a></li></ul></li></ul><!-- tocstop --><h2><span id="持续集成流程">持续集成流程</span></h2><pre class="mermaid">graph LR    获取代码 --> 编码    编码 -.-> 编写单元测试    编写单元测试 -->上传代码    编码 -->上传代码    上传代码 --人工触发-->jenkins编译    上传代码 --自动触发-->jenkins编译    jenkins编译 --编译成功--> 执行单元测试    jenkins编译 --编译失败--> 获取代码    执行单元测试 --单元测试成功--> 持续部署    执行单元测试 --单元测试失败--> 获取代码</pre><ol><li>开发人员获取代码进行编码</li><li>编码后若有需要则编写单元测试，单元测试通过后，进行自测功能。</li><li>测试通过后上传代码。</li><li>人工执行或自动触发jenkens构建。</li><li>jenkins构建失败，则开发重新获取代码解决问题。</li><li>jenkins构建成功，有必要则执行测试。</li><li>单元测试执行通过后开始持续部署。</li></ol><h2><span id="持续部署流程">持续部署流程</span></h2><pre class="mermaid">graph LR    持续集成 --成功--> 备份原始文件    备份原始文件 --> 上传文件    上传文件 -.失败.-> 恢复备份文件    恢复备份文件 --> 人工干预处理    上传文件 --成功--> 修改配置    修改配置 --> 执行数据脚本    执行数据脚本 --> 关闭服务    关闭服务 --> 启动服务    持续集成 --失败--> 编码</pre><ol><li>持续集成完成后备份目标服务器对应程序的库包文件。</li><li>将jenkens编译成功后的库包文件上传到目标服务器对应的程序目录下。</li><li>人工修改配置文件。</li><li>人工执行数据库脚本。</li><li>人工重启服务</li></ol><h2><span id="测试环境发布测试流程">测试环境发布测试流程</span></h2><p>针对首次在 <code>.net小组</code>引入自动化流程(持续集成、持续部署),现在测试环境对流程进行试验及合理化流程。</p><h3><span id="原始流程">原始流程</span></h3><ol><li>开发</li></ol><pre class="mermaid">graph LR    开发编码 --> 本地测试    本地测试 --通过--> 上传代码    上传代码 --> 编写配置修改文档    编写配置修改文档 --> 配置修改文档上传    配置修改文档上传 --> 库包上传    库包上传--> 测试人员测试    测试人员测试 --测试通过--> 发版    测试人员测试 --测试不通过--> 开发编码</pre><p>2.测试</p><pre class="mermaid">graph LR更新库包--> 测试环境库包备份测试环境库包备份 --> 升级程序升级程序--> 根据文档修改配置根据文档修改配置-->重启程序</pre><ol><li>开发人员编码本地测试通过后打包</li><li>开发人员根据配置修改编写配置修改文档（包括配置修改和数据库脚本等）</li><li>将库包、配置修改文档和数据库脚本都上传到SVN的冲突包。</li><li>通知测试人员，测试更新的程序。</li><li>测试人员备份源程序后升级程序。</li><li>测试人员根据配置修改文档修改配置。</li><li>测试人员执行数据库脚本。</li><li>启动程序进行测试。</li><li>测试通过后发版，同时开发人员将版本切出release分支备份代码。</li></ol><blockquote><p>所有开发都在trunk上，一个版本开发完成后切除一个release分支,如有补丁包要发版，则在对应的release分支上切出一个branch分支。补丁包发版后将branch合并到trunk,新的版本需要重新测试合并后的代码。</p></blockquote><h3><span id="自动化流程">自动化流程</span></h3><ol><li>自动化打包</li></ol><p>第一个阶段先将自动化打包融入到开发流程中，从原来手动进行冲突包合并并打包的工作交给jenkins进行处理。</p><pre class="mermaid">graph LR    切出新版本分支--> 开发编码    开发编码 --> 本地测试    本地测试 --通过--> 上传代码    上传代码 --> 编写配置修改文档    编写配置修改文档 --> 配置修改文档上传    配置修改文档上传 --> 代码上传    代码上传 --> 执行jenkins编译    执行jenkins编译--> 上传到测试环境</pre>]]></content>
      
      
      <categories>
          
          <category> 规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 持续集成 </tag>
            
            <tag> 持续部署 </tag>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>powershell使用winrm远程调用</title>
      <link href="/2019/03/21/powershell%E4%BD%BF%E7%94%A8winrm%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
      <url>/2019/03/21/powershell%E4%BD%BF%E7%94%A8winrm%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1><span id="介绍">介绍</span></h1><p>winrm是windows一种方便远程管理的服务。</p><h1><span id="服务端配置">服务端配置</span></h1><ol><li><p>快速配置<br><code>winrm quickconfig</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; winrm quickconfig</span><br><span class="line">在此计算机上，WinRM 已设置为接收请求。</span><br><span class="line">WinRM 没有设置成为了管理此计算机而允许对其进行远程访问。</span><br><span class="line">必须进行以下更改:</span><br><span class="line"></span><br><span class="line">在 HTTP://* 上创建 WinRM 侦听程序接受 WS-Man 对此机器上任意 IP 的请求</span><br><span class="line">启用 WinRM 防火墙异常。</span><br><span class="line">配置 LocalAccountTokenFilterPolicy 以远程向本地用户授予管理权限。</span><br><span class="line"></span><br><span class="line">进行这些更改吗[y/n]? y</span><br><span class="line"></span><br><span class="line">WinRM 已经进行了更新，以用于远程管理。</span><br><span class="line"></span><br><span class="line">在 HTTP://* 上创建 WinRM 侦听程序接受 WS-Man 对此机器上任意 IP 的请求</span><br><span class="line">WinRM 防火墙异常已启用。</span><br><span class="line">已配置 LocalAccountTokenFilterPolicy 以远程向本地用户授予管理权限。</span><br></pre></td></tr></table></figure></li><li><p>查看winrm当前监听<br><code>winrm enumerate winrm/config/listener</code></p> <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; winrm enumerate winrm/config/listener</span><br><span class="line">Listener</span><br><span class="line">    Address = *</span><br><span class="line">    Transport = HTTP</span><br><span class="line">    Port = <span class="number">5985</span></span><br><span class="line">    Hostname</span><br><span class="line">    Enabled = true</span><br><span class="line">    URLPrefix = wsman</span><br><span class="line">    CertificateThumbprint</span><br><span class="line">    ListeningOn = <span class="number">10.60</span>.<span class="number">45.239</span>, <span class="number">127.0</span>.<span class="number">0.1</span>, <span class="number">169.254</span>.<span class="number">95.120</span>, <span class="number">169.254</span>.<span class="number">109.205</span>, <span class="number">192.168</span>.<span class="number">86.1</span>, <span class="number">192.168</span>.<span class="number">246.1</span>, ::<span class="number">1</span>, fe80::<span class="number">100</span>:</span><br><span class="line"><span class="number">7</span>f:fffe%<span class="number">15</span>, fe80::<span class="number">5</span>efe:<span class="number">10.60</span>.<span class="number">45.239</span>%<span class="number">16</span>, fe80::<span class="number">5</span>efe:<span class="number">169.254</span>.<span class="number">95.120</span>%<span class="number">14</span>, fe80::<span class="number">5</span>efe:<span class="number">192.168</span>.<span class="number">86.1</span>%<span class="number">19</span>, fe80::<span class="number">5</span>efe:<span class="number">192.168</span>.<span class="number">246</span></span><br><span class="line">.<span class="number">1</span>%<span class="number">21</span>, fe80::<span class="number">9</span>a3:<span class="number">61</span>f8:<span class="number">58</span>da:<span class="number">8641</span>%<span class="number">18</span>, fe80::<span class="number">3085</span>:<span class="number">69</span>a3:<span class="number">108</span>b:<span class="number">8</span>e47%<span class="number">20</span>, fe80::<span class="number">6085</span>:<span class="number">3334</span>:edcd:e804%<span class="number">13</span>, fe80::<span class="number">69</span>f2:af65:cf47:<span class="number">6</span>dc</span><br><span class="line">d%<span class="number">12</span>, fe80::bd06:af81:b232:<span class="number">11</span>ff%<span class="number">11</span></span><br></pre></td></tr></table></figure></li><li><p>启动winrm<br><code>Enable-PSRemoting –Force</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    PS C:\Users\Administrator&gt; <span class="built_in">Enable-PSRemoting</span> –Force</span><br><span class="line">    在此计算机上，WinRM 已设置为接收请求。</span><br><span class="line">    WinRM 已经进行了设置，以用于在此计算机上进行远程管理。</span><br><span class="line">   ``` </span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. 允许执行powershell脚本</span><br><span class="line">   `set-ExecutionPolicy RemoteSigned`</span><br><span class="line">   ``` powershell</span><br><span class="line">    PS C:\Users\Administrator&gt; <span class="built_in">set-ExecutionPolicy</span> RemoteSigned</span><br><span class="line"></span><br><span class="line">    执行策略更改</span><br><span class="line">    执行策略可以防止您执行不信任的脚本。更改执行策略可能会使您面临 about_Execution_Policies</span><br><span class="line">    帮助主题中所述的安全风险。是否要更改执行策略?</span><br><span class="line">    [Y] 是(Y)  [N] 否(N)  [S] 挂起(S)  [?] 帮助 (默认值为“Y”): y</span><br></pre></td></tr></table></figure></li><li><p>获取winrm配置的客户端<br><code>winrm get winrm/config/client</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator&gt; winrm get winrm/config/client</span><br><span class="line"> Client</span><br><span class="line">     NetworkDelayms = <span class="number">5000</span></span><br><span class="line">     URLPrefix = wsman</span><br><span class="line">     AllowUnencrypted = false</span><br><span class="line">     Auth</span><br><span class="line">         Basic = true</span><br><span class="line">         Digest = true</span><br><span class="line">         Kerberos = true</span><br><span class="line">         Negotiate = true</span><br><span class="line">         Certificate = true</span><br><span class="line">         CredSSP = false</span><br><span class="line">     DefaultPorts</span><br><span class="line">         HTTP = <span class="number">5985</span></span><br><span class="line">         HTTPS = <span class="number">5986</span></span><br><span class="line">     TrustedHosts</span><br></pre></td></tr></table></figure></li><li><p>设置信用地址<br> <code>winrm set winrm/config/client @{TrustedHosts=&quot;host1, host2, host3&quot;}</code><br> <code>Set-Item wsman:\localhost\client\trustedhosts *</code></p></li></ol><h1><span id="客户端远程调用">客户端远程调用</span></h1><ol><li>远程调用</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$account</span> = <span class="string">"administrator"</span></span><br><span class="line"><span class="variable">$password</span> = <span class="string">'test1'</span></span><br><span class="line"><span class="variable">$secpwd</span> = <span class="built_in">convertto-securestring</span> <span class="variable">$password</span> -asplaintext -force</span><br><span class="line"><span class="variable">$cred</span> = <span class="built_in">new-object</span> System.Management.Automation.PSCredential -argumentlist <span class="variable">$account</span>,<span class="variable">$secpwd</span></span><br><span class="line"><span class="built_in">invoke-command</span> -computername <span class="number">10.60</span>.<span class="number">45.239</span> -Credential <span class="variable">$cred</span>  -command &#123;d:helloworld.ps1&#125;</span><br></pre></td></tr></table></figure><ol><li><p><a href="https://cloud.tencent.com/info/a410c623cb0de5396ce4330effb7efe3.html" target="_blank" rel="noopener">windows服务器远程执行命令（PowerShell+WinRM）</a></p></li><li><p><a href="https://www.cnblogs.com/weloveshare/p/5569719.html" target="_blank" rel="noopener">winServer-常用winrm命令</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 持续部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> powershell </tag>
            
            <tag> winrm </tag>
            
            <tag> windows远程调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统架构设计V0.2</title>
      <link href="/2019/03/18/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1V0.2/"/>
      <url>/2019/03/18/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1V0.2/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1><span id="系统架构设计">系统架构设计</span></h1><p>为了满足网络通讯的低延迟、高并发、高可用的要求，设计了高性能网络通讯+高可用系统架构。</p><p><img src="//guojielin.github.io/2019/03/18/系统架构设计V0.2/2019-03-14-19-41-07.png" alt="2019-03-14-19-41-07.png"></p><p>系统整体分为4层: 网络层、通讯框架层、线程模型、接口层。</p><h2><span id="网络模型">网络模型</span></h2><p>网络IO模型主使用完成端口+重叠I/O模型的方式处理。通过该模型极大的提升了线程利用率，降低了线程上下文切换。</p><blockquote><p>完成端口全称为输入输出完成端口（Input/Output Completion Port，IOCP）， 是支持多个同时发生的异步I/O操作的应用程序编程接口。<br>重叠I/O模型是一种异步IO模型。多线程结构中就考虑到采用异步的方式进行设备读写操作，即我们告诉系统对设备的读写数据，而同时应用程序的其他代码继续执行，直到获取设备操作完毕的系统通知。</p></blockquote><p>相比同步阻塞、同步非阻塞网络IO模型，异步非阻塞模型在减少了资源占用的同时，充分的利用了线程，最大的提升网络通讯性能。</p><h2><span id="通讯层">通讯层</span></h2><p>通讯层使用了 NetMQ框架，NetMQ是开源的网络通讯框架，它对标准socket接口的扩展。它提供了一种异步消息队列，多消息模式，消息过滤（订阅），对多种传输协议的无缝访问。</p><h2><span id="线程模型">线程模型</span></h2><p>为了达成高性能的要求，基于异步事件驱动模型，避免线程阻塞而浪费线程资源，通过完全异步的方式极大的提升了线程利用率。</p><p><img src="//guojielin.github.io/2019/03/18/系统架构设计V0.2/2019-03-18-16-44-54.png" alt></p><ol><li>接收到前端服务数据时先加入到队列中。</li><li>工作线程获取到会话进行业务处理。</li><li>业务处理完有必要时发送到后端系统，发送完后此时不会阻塞等待返回，而是继续处理下一个会话。</li><li>当后端返回时将接收到的数据加入到队列中。</li><li>工作线程取到后端返回的会话继续进行必要的业务处理。</li><li>处理完后返回前端系统。</li></ol><h2><span id="接口层">接口层</span></h2><p>通过标准的接口指定了交易、查询、对账、退票等接口方案，简化了企业对接流程。</p><h2><span id="系统对接">系统对接</span></h2><p>传统方式使用冷备进行不同系统对接。</p><blockquote><p>冷备技术，部署备用服务，在2台(或多台)服务器运行的时候，当正在提供服务的这台服务器出现故障后，人工手动切换到另一台服务器，保障系统的可以继续运行服务。</p></blockquote><p><img src="//guojielin.github.io/2019/03/18/系统架构设计V0.2/2019-03-18-16-31-14.png" alt="2019-03-18-16-31-14.png"></p><p>从理论上来说，作为一个正常人，收到突发报警、能正确的分析出问题所在、找到正确的解决方案、并且<strong>正确实施</strong>的时间极限大概是<strong>两分钟</strong>。但是对于实际情况，人工处理效率远大于该极限值。一般人工发现问题并找到问题原因，最终到解决问题可能至少要20分钟以上。</p><p>为了提高服务可用率和服务可靠性，系统支持采用热备方式对接后端服务。</p><p><img src="//guojielin.github.io/2019/03/18/系统架构设计V0.2/2019-03-14-16-42-47.png" alt="2019-03-14-16-42-47.png"></p><h3><span id="负载均衡">负载均衡</span></h3><p>当前端服务和后端服务采用热备的方式接入时，通过加权轮询算法自动将请求分配到指定的后端服务。<br>假设有前端服务A和后端服务B1和B2连接，B1的权重为1，B2的权重为2，则服务均衡分配如下</p><p>开始服务节点计数都为0。</p><p><img src="//guojielin.github.io/2019/03/18/系统架构设计V0.2/2019-03-18-17-37-26.png" alt="2019-03-18-17-37-26.png"></p><p>第1次接收到前端服务请求时先分配到后端服务A，此时服务A的计数为1。</p><p><img src="//guojielin.github.io/2019/03/18/系统架构设计V0.2/2019-03-18-17-37-45.png" alt="2019-03-18-17-37-45.png"></p><p>第2次接收到前端服务请求时分配到后端服务B，此时服务B的计数为1。</p><p><img src="//guojielin.github.io/2019/03/18/系统架构设计V0.2/2019-03-18-17-38-03.png" alt="2019-03-18-17-38-03.png"></p><p>第3次接收到前端服务请求时，由于服务A和服务B的比重为1:2,因此还是分配到后端服务B，此时服务B的计数为2。</p><p><img src="//guojielin.github.io/2019/03/18/系统架构设计V0.2/2019-03-18-17-38-13.png" alt="2019-03-18-17-38-13.png"></p><p>第4次接收到前端服务请求时，由于服务A和服务B的比重为1:2,此时服务A和服务B的请求数量已经达到1:2,因此分配到后端服务A，此时服务A的计数为2。</p><p><img src="//guojielin.github.io/2019/03/18/系统架构设计V0.2/2019-03-18-17-38-27.png" alt="2019-03-18-17-38-27.png"></p><h3><span id="服务容错">服务容错</span></h3><p>通过服务容错机制可以更加智能的选择可用服务节点，当检测到后端某个服务节点不可用时，将服务节点禁用。</p><p>当前服务A和服务B的计数为2:2。若此时服务B不可用了，则后续请求全部会转发到服务A。</p><p><img src="//guojielin.github.io/2019/03/18/系统架构设计V0.2/2019-03-21-10-24-19.png" alt="2019-03-21-10-24-19.png"></p><p><img src="//guojielin.github.io/2019/03/18/系统架构设计V0.2/2019-03-21-10-24-34.png" alt="2019-03-21-10-24-34.png"></p><blockquote><p>后端可对服务是否可用进行控制，当某服务节点故障或升级时，将该服务节点置为不可用状态，此时服务全部分配到其他可用节点。</p></blockquote><h3><span id="服务恢复">服务恢复</span></h3><p>基于心跳检测，会实时的检测当服务节点可用状态，当服务节点恢复时，请求会继续发送到可用服务节点。同时将计数清零重新计数。</p><p><img src="//guojielin.github.io/2019/03/18/系统架构设计V0.2/2019-03-18-17-37-26.png" alt="2019-03-18-17-37-26.png"></p><p><img src="//guojielin.github.io/2019/03/18/系统架构设计V0.2/2019-03-18-17-37-45.png" alt="2019-03-18-17-37-45.png"></p><p><img src="//guojielin.github.io/2019/03/18/系统架构设计V0.2/2019-03-18-17-38-03.png" alt="2019-03-18-17-38-03.png"></p><h3><span id="服务扩容">服务扩容</span></h3><p>服务需要扩容时，通过配置的方式可以方便的进行扩容。</p><p><img src="//guojielin.github.io/2019/03/18/系统架构设计V0.2/2019-03-21-10-28-00.png" alt="2019-03-21-10-28-00.png"></p><h3><span id="冷备vs热备">冷备VS热备</span></h3><p>在不同系统通过网络对接时，通过SLA(Service Level Agreement，服务等级协议)可以清晰的表现出服务可用时间。</p><table><thead><tr><th>可用时间(百分比)</th><th>不可用时间(每年)</th><th>不可用时间(每天)</th></tr></thead><tbody><tr><td>90%</td><td>36.5天</td><td>2.4小时</td></tr><tr><td>99%</td><td>3.65天</td><td>14分钟</td></tr><tr><td>99.9%</td><td>8.76小时</td><td>86秒</td></tr><tr><td>99.99%</td><td>52.6分</td><td>8.6秒</td></tr><tr><td>99.999%</td><td>5.25分</td><td>0.86秒</td></tr><tr><td>99.9999%</td><td>31.5秒</td><td>0.86秒</td></tr></tbody></table><p>一般来说专线网络接入的SLA可以达到99.99%，VPN网络接入的SLA可以到99.96%。下面通过一些数据对比冷备和热备的在使用专线情况下的服务可靠性。</p><blockquote><p>假设每次升级服务需要10分钟，每次故障到解决需要20分钟。</p></blockquote><table><thead><tr><th>升级次数(每年)</th><th>故障次数(每年)</th><th>冷备可用时间百分比</th><th>冷备不可用时间(每年)</th><th>热备可用时间百分比</th><th>热备不可用时间(每年)</th></tr></thead><tbody><tr><td>1次</td><td>0</td><td>99.988%</td><td>62.6分</td><td>99.99%</td><td>52.6分</td></tr><tr><td>3次</td><td>0</td><td>99.98%</td><td>82.6分</td><td>99.99%</td><td>52.6分</td></tr><tr><td>12次</td><td>0</td><td>99.967%</td><td>172.6分</td><td>99.99%</td><td>52.6分</td></tr><tr><td>12次</td><td>1次</td><td>99.963%</td><td>192.6分</td><td>99.99%</td><td>52.6分</td></tr><tr><td>12次</td><td>3次</td><td>99.955%</td><td>232.6分</td><td>99.99%</td><td>52.6分</td></tr><tr><td>12次</td><td>6次</td><td>99.944%</td><td>292.6分</td><td>99.99%</td><td>52.6分</td></tr></tbody></table><p>可以从上表看到，若每月服务升级1次，每2个月出现1次异常故障。则使用冷备时服务最高可靠时间为99.94%，而想要达到必须满足以下前提条件：<strong>1. 每次服务升级不出任何问题；2. 完善的预警系统；3. 快速的定位问题；4. 超强的问题解决能力；5. 运维人员3班倒，时刻关注预警消息。</strong><br>热备由于支持通过负载均衡，容错机制自动切换到可用节点，不会因为单台服务节点升级和异常故障对其造成影响。除非多条线路同时故障，才会对热备造成影响。因此热备的服务可用时间可以认为几乎等于运营商网络的服务可用时间。</p>]]></content>
      
      
      <categories>
          
          <category> 系统架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> 系统架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统架构V0.4</title>
      <link href="/2019/03/14/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84V0.4/"/>
      <url>/2019/03/14/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84V0.4/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1><span id="系统架构">系统架构</span></h1><h2><span id="背景">背景</span></h2><p>随着Internet的快速发展和业务量的不断提高，基于网络的数据访问流量迅速增长，同时许多企业的网站或接口都需要提供<strong>7*24</strong>小时不间断访问，任何服务中断都会直接或间接的造成商业损失，因此企业对于应用服务提出了高性能和高可靠性的要求。随着用户量和数据量的急速递增，传统的单机模式，不但成为性能瓶颈，也会存在单点故障，<strong>系统架构升级</strong>刻不容缓。</p><h2><span id="系统演化">系统演化</span></h2><h3><span id="单机系统">单机系统</span></h3><p>企业对接时，一开始数据量并不大，前端系统和后端服务都只用部署1个即可。</p><p><img src="//guojielin.github.io/2019/03/14/系统架构V0.4/2019-03-07-17-58-17.png" alt="2019-03-07-17-58-17.png"></p><h3><span id="冷备">冷备</span></h3><p>一开始只有1个服务没有什么影响，但是随着服务长时间运行，会碰到服务升级，网络不通等情况，就会存在服务长时间无法访问。此时就非常需要添加一个备用服务器。<br>冷备技术，部署备用服务，在2台(或多台)服务器运行的时候，当正在提供服务的这台服务器出现故障后，人工手动切换到另一台服务器，保障系统的可以继续运行服务。</p><p><img src="//guojielin.github.io/2019/03/14/系统架构V0.4/2019-03-08-11-20-55.png" alt="2019-03-08-11-20-55.png"></p><p>虽然双机冷备能起到临时解决作用，但是服务器切换的时候难免需要人工处理时间，在人工处理时，服务往往是不可用的。<br>一般来说网络服务供应商和客户之前会有一份关于可用性的合同，其衡量标准即为SLA(Service Level Agreement,服务等级协议),该衡量标准同样也适用于企业服务。</p><table><thead><tr><th>可用时间(百分比)</th><th>不可用时间(每年)</th><th>不可用时间(每天)</th></tr></thead><tbody><tr><td>90%</td><td>36.5天</td><td>2.4小时</td></tr><tr><td>99%</td><td>3.65天</td><td>14分钟</td></tr><tr><td>99.9%</td><td>8.76小时</td><td>86秒</td></tr><tr><td>99.99%</td><td>52.6分</td><td>8.6秒</td></tr><tr><td>99.999%</td><td>5.25分</td><td>0.86秒</td></tr><tr><td>99.9999%</td><td>31.5秒</td><td>0.86秒</td></tr></tbody></table><p>一般来说，我们的观念里一个服务至少要做到99.9%才称为基本上可用，是合格性产品，否则基本很难被别人使用。理论上来说，作为一个正常人类，收到突发报警、能正确的分析出问题所在、找到正确的解决方案、并且<strong>正确实施</strong>的时间极限大概是<strong>两分钟</strong>[^1]。但是对于实际情况，人工处理效率远大于该极限值。一般人工发现问题并找到问题原因，最终到解决问题可能至少要20分钟以上。可以想象的出2个9(99%)、3个(99.9%)是基本可以靠运气搞定的。到3个9可以靠堆人(也就是3班倒之类的强制值班)。但是在信息时代，设备是不值钱的，人力才是真正的资源。为了达到4个9的SLA标准，不得不提到高可用。</p><h3><span id="热备">热备</span></h3><p>热备(高可用)特指基于高可用系统中的两台(或多台)服务器的热备。简单的讲，热备就是一种利用故障点转移的方式来保障业务连续性。其业务的恢复不是在原服务器，而是在备用服务器。热备不具有修复故障服务器的功能，而只是将故障隔离。</p><p><img src="//guojielin.github.io/2019/03/14/系统架构V0.4/2019-03-14-16-42-47.png" alt="2019-03-14-16-42-47.png"></p><p>当启用了热备以后，虽然避免了单机故障，但是同时引入了新的问题。前端系统如何决定请求发往哪个后端服务？这时候就要通过负载均衡对请求进行分发。</p><h4><span id="负载均衡">负载均衡</span></h4><p>负载均衡是建立在现有网络结构之上，提供一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。通常负载均衡有两方面的含义。</p><ol><li>单个重负载的运算分担到多台节点设备上做并行处理，每个节点设备处理结束后，将结果汇总，返回给用户，系统处理能力得到大幅度提高，这就是常说的集群（clustering）技术。</li><li>大量的并发访问或数据流量分担到多台节点设备上分别处理，减少用户等待响应的时间，这主要针对Web服务器、FTP服务器、企业关键应用服务器等网络应用。通常，负载均衡会根据网络的不同层次（网络七层）来划分。目前所用到的负载均衡技术通常在网络协议的的第4层(传输层)或第7层(应用层)处理的。</li></ol><h4><span id="作用">作用</span></h4><ol><li>解决并发压力，提高应用处理性能。</li><li>提供故障转移，实现高可用。</li><li>通过添加或减少服务器数量，提供网站伸缩性（扩展性）。</li><li>安全防护；（负载均衡设备上做一些过滤，黑白名单等处理）。</li></ol><h4><span id="解决方案">解决方案</span></h4><h5><span id="dns负载均衡">DNS负载均衡</span></h5><p>早期的负载均衡是通过DNS实现的，通过将一个域名指向多个IP，当请求通过DNS服务器，根据指定的负载均衡策略(如随机分配、轮询等算法)返回指定IP。这样做配置简单，扩展性强。但是这种方法有一个很大的缺点就是延时性问题，在做出调度策略改变以后，由于DNS各级节点的缓存并不会及时的在客户端生效，而且DNS负载的调度策略比较简单，无法满足业务需求。</p><h5><span id="硬件负载均衡">硬件负载均衡</span></h5><p>硬件负载均衡器也称为F5，是处于网络协议<strong>传输层</strong>的负载均衡解决方案，是直接在服务器和外部网络间安装负载均衡设备，由于专门的设备完成专门的任务，独立于操作系统，整体性能得到大量提高，加上多样化的负载均衡策略，智能化的流量管理，可达到最佳的负载均衡需求。</p><p><img src="//guojielin.github.io/2019/03/14/系统架构V0.4/2019-03-08-11-12-36.png" alt="2019-03-08-11-12-36.png"></p><p>负载均衡器的工作是转发报文，接收到请求时，修改数据包的目标地址，从而将包转发到指定的应用服务器。使用负载均衡器功能和性能都很不错，但是价格比较昂贵，且负载均衡器本身又会变为一个单点。虽然现在主流的负载均衡器也都支持主备容灾功能，但是理论上需要形成1+2(1主2备)才能实现真正的高可用，其中一台挂掉后依然还是1主1备，但是主要还是价格比较昂贵。</p><h5><span id="软件负载均衡">软件负载均衡</span></h5><p>由于硬件负载均衡虽然性能很好，但是非常昂贵，随着负载均衡的负载，基于软件的负载均衡方案脱颖而出，它的有点是费用低廉，实现功能强大。Nginx/LVS/HAProxy是目前使用最广泛的三种负载均衡软件。</p><h6><span id="nginx">Nginx</span></h6><p>Nignx是在应用层上实现的一个基于反向代理的软件。针对Http应用做了分流策略，通过Nginx解析Http头部将请求分发到配置的指定服务器。同时通过简单的配置即可实现后端服务集群配置，通过内置的负载均衡算法将请求分配到指定的服务。Nginx也支持部署集群，可以避免反向代理服务本身存在单点故障。然而Nginx最大的缺点之一就是仅支持HTTP、HTTPS、EMail等协议，适用范围较小。</p><blockquote><p>反向代理，在接收到前端请求后，根据负载均衡算法分配到其中一个后端地址，然后反向代理软件所在的服务器与后端服务器建立TCP连接。这种方式可以对前端的请求和后端的响应的数据进行任意修改，极大的提升了应用系统在网络层的灵活性。但同时，对性能的要求也增强了。</p></blockquote><p><img src="//guojielin.github.io/2019/03/14/系统架构V0.4/2019-03-08-11-12-03.png" alt="2019-03-08-11-12-03.png"></p><h6><span id="lvs">LVS</span></h6><p>LVS使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。LVS有三种模式，分别为NAT(网络地址转换)、TUN(隧道)、DR(直接路由)。</p><ol><li>NAT模式对数据包的IP和端口进行修改并转发。</li><li>TUN模式通过IP隧道(将IP数据报封装到IP数据报中的技术)对IP数据包再次封装并转发。</li><li>DR模式通过对Linux的内核参数进行一定的配置之后，通过修改请求的MAC地址将其转发到指定的后端服务，从而实现转发。</li></ol><p>因为它工作在传输层，因此比Nignx更为高效，也因此它不能和Nginx一样解析应用层数据包做动静分离，相比于Nginx的功能就显得没那么强大。</p><h6><span id="haproxy">HAProxy</span></h6><p>Haproxy是高可用代理软件，它是一种比较流行的开源软件，基于TCP(四层)/HTTP(七层)协议的负载均衡代理解决方案，可以在Linux、FreeBSD等平台下运行，常见于跨多个服务器，比如:web、应用程序、数据库、MQ消息队列、MC数据库等等。通过多个Haproxy服务来提高服务的性能和可靠性。HAProxy基于第四层负载均衡逻辑是通过转发到指定的服务IP和端口，类似于LVS-NAT模式。第七层负载均衡原理和Nginx类似。</p><h4><span id="负载均衡算法">负载均衡算法</span></h4><ol><li>轮询法<br>将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</li><li>随机法<br>通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，<br>其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</li><li>源地址哈希法<br>源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</li><li>加权轮询法<br>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</li><li>加权随机法<br>与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</li><li>最小连接数法<br>最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前<br>积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</li></ol><h4><span id="负载均衡容错">负载均衡容错</span></h4><p>负载均衡除了分配服务以外，容错机制也是必不可少的功能。容错机制通过自动侦测、自动切换和自动恢复3个阶段完成。</p><h5><span id="自动侦测">自动侦测</span></h5><p>通过判断服务节点的网络、负载等情况决定服务节点可用性。</p><ol><li>端口连通性<br>我们可以通过一个端口是否可连通作为节点是否可用的基本判断。</li><li>服务可用<br>在大多数情况，端口连通并不一定可以提供服务。因此为了提高容错率，我们需要考虑服务可用性。可以添加一个特定的接口，用于返回服务是否可用，返回的指标有很多，比如服务的负载情况，服务所在服务器的负载情况等。<ul><li>使用HTTP协议：可以判断HTTP的状态码，如每个节点都状态码为200时表示服务可用，状态码非200时服务不可用。</li><li>使用TCP协议：TCP并没有状态码，因此我们需要自定义的报文返回服务是否可用。</li></ul></li></ol><h5><span id="自动切换">自动切换</span></h5><p>当自动侦测到某节点不可用时，则需要根据规则进行容灾处理，比如将服务节点从可用节点移除，发送预警通知等。</p><h5><span id="自动恢复">自动恢复</span></h5><p>当侦测到服务可用时，可以自动进行注册到可用服务列表中。</p><h2><span id="参考文献">参考文献</span></h2><ol><li><a href="http://www.cnblogs.com/danbing/p/7459224.html" target="_blank" rel="noopener">负载均衡基础知识</a></li><li><a href="https://blog.csdn.net/github_37515779/article/details/79953788" target="_blank" rel="noopener">高并发解决方案之一 ——负载均衡</a></li><li><a href="https://www.jianshu.com/p/c91fe3f94e5c" target="_blank" rel="noopener">什么是负载均衡，为什么要做负载均衡？</a></li><li><a href="https://www.jianshu.com/p/b67af78f1088" target="_blank" rel="noopener">浅析负载均衡的6种算法，Ngnix的5种算法</a></li></ol><p>[^1]: 杨卫华. 高可用架构·硅谷篇（第4期）.</p>]]></content>
      
      
      <categories>
          
          <category> 系统架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统架构设计V0.1</title>
      <link href="/2019/03/14/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1V0.1/"/>
      <url>/2019/03/14/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1V0.1/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1><span id="系统架构设计">系统架构设计</span></h1><p>为了满足网络通讯的低延迟、高并发、高可用的要求，设计了高性能网络通讯+高可用系统架构。</p><p><img src="//guojielin.github.io/2019/03/14/系统架构设计V0.1/2019-03-14-19-41-07.png" alt></p><p>系统整体分为4层: 网络层、通讯框架层、线程模型、接口层。</p><h2><span id="网络模型">网络模型</span></h2><p>网络IO模型主使用完成端口+重叠I/O模型的方式处理。通过该模型极大的提升了线程利用率，降低了线程上下文切换。</p><blockquote><p>完成端口全称为输入输出完成端口（Input/Output Completion Port，IOCP）, 是支持多个同时发生的异步I/O操作的应用程序编程接口。<br>重叠I/O模型是一种异步IO模型。多线程结构中就考虑到采用异步的方式进行设备读写操作，即我们告诉系统对设备的读写数据，而同时应用程序的其他代码继续执行，直到获取设备操作完毕的系统通知。</p></blockquote><p>相比同步阻塞、同步非阻塞网络IO模型，异步非阻塞模型在减少了资源占用的同时，充分的利用了线程，最大的提升网络通讯性能。</p><h2><span id="通讯层">通讯层</span></h2><p>通讯层使用了 NetMQ框架，NetMQ是开源的网络通讯框架,它对标准socket接口的扩展。它提供了一种异步消息队列,多消息模式,消息过滤（订阅）,对多种传输协议的无缝访问。</p><h2><span id="线程模型">线程模型</span></h2><p>为了达成高性能的要求，基于异步事件驱动模型，避免线程阻塞而浪费线程资源，通过完全异步的方式极大的提升了线程利用率。</p><p><img src="//guojielin.github.io/2019/03/14/系统架构设计V0.1/2019-03-14-20-31-36.png" alt></p><ol><li>接收到前端数据时先加入到队列中</li><li>工作线程获取到会话进行业务处理</li><li>业务处理完有必要时发送到后端系统，发送完后此时不会阻塞等待返回，而是继续处理下一个会话。</li><li>当后端返回时将接收到的数据加入到队列中</li><li>工作线程取到后端返回的会话继续进行必要的业务处理</li><li>处理完后返回前端系统</li></ol><h2><span id="接口层">接口层</span></h2><p>通过标准的接口指定了交易、查询、对账、退票等接口方案，简化了企业对接流程。</p><h2><span id="系统对接">系统对接</span></h2><p>在和后端的网络通讯上，支持服务高可用，后端通过集群部署多个服务，允许前端通过负载均衡算法进行服务分配。</p><p><img src="//guojielin.github.io/2019/03/14/系统架构设计V0.1/2019-03-14-16-42-47.png" alt="2019-03-14-16-42-47.png"></p><p>通过服务容错算法极大的提升了服务可靠性。当检测到后端某个服务节点不通时，将节点禁用。当节点恢复时自动恢复节点可用性。同时基于心跳检测，异常预警等机制可以更快的发现问题，及时处理。</p>]]></content>
      
      
      <categories>
          
          <category> 系统架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> 系统架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保融前置机系统架构0.1</title>
      <link href="/2019/03/05/%E4%BF%9D%E8%9E%8D%E5%89%8D%E7%BD%AE%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84V-1/"/>
      <url>/2019/03/05/%E4%BF%9D%E8%9E%8D%E5%89%8D%E7%BD%AE%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84V-1/</url>
      
        <content type="html"><![CDATA[<h1><span id="保融前置机系统架构">保融前置机系统架构</span></h1><h2><span id="背景">背景</span></h2><p>企业和保融之前使用保融标准接口进行对接。为了减轻企业的开发压力。保融为企业开发了企业前置机，在前置机上进行签名、验签、加密、解密等功能。企业只需要根据接口文档生成报文与前置机对接即可，降低了企业对接开发工作量。</p><h2><span id="名词解释">名词解释</span></h2><table><thead><tr><th>名词</th><th>解释</th></tr></thead><tbody><tr><td>老版本前置机</td><td>版本为V2.5版本的前置机，使用老的网络通讯框架，网络通讯性能存在一定瓶颈</td></tr><tr><td>新版本前置机</td><td>版本大于V2.5版本的前置机，使用新的网络通讯框架，同时添加了一些新的功能，相比老版本前置机，性能提升明显。</td></tr></tbody></table><h2><span id="前置机系统架构">前置机系统架构</span></h2><p><img src="//guojielin.github.io/2019/03/05/保融前置机系统架构V-1/2019-03-07-14-46-22.png" alt></p><p>新版本前置机使用开源的NetMQ网络通讯框架,底层使用<code>异步IO</code>+<code>重叠模型</code>进行网络通信，极大增强了前置机网络通讯能力。同时，在网络异步通讯架构的基础上，线程模型也采用异步(非阻塞)模式处理，提升了线程利用率，提高了业务处理并发量。</p><blockquote><p>老版本已经逐渐淘汰使用，不再做详细的架构介绍。</p></blockquote><h2><span id="保融前置机部署方案">保融前置机部署方案</span></h2><p>由于前置机上需要进行签名验签等CPU密集型操作，因此主要在CPU处理上存在处理性能瓶颈，需要企业部署多台前置机进行水平扩展，同时可以解决前置机单点故障。</p><p>目前前置机有以下几种部署方案：</p><ol><li>双机冷备。</li><li>双机热备。</li></ol><h3><span id="双机冷备">双机冷备</span></h3><p>双机冷备技术，部署备用服务，在2台(或多台)服务器运行的时候，当正在提供服务的这台服务器出现故障后，人工手动切换到另一台服务器，保障系统的可以继续运行服务。</p><p><img src="//guojielin.github.io/2019/03/05/保融前置机系统架构V-1/2749555-1G121151T21A.png" alt="2749555-1G121151T21A.png"></p><p>老版本前置机由于存储了一些本地批次缓存信息，因此批量业务有以下限制，发送到哪台前置机做的交易就必须发送到该前置机进行查询。因此老版本由于数据无法共享，因此只能支持冷备。老版本前置机的冷备方案如下:</p><ol><li>前置机A挂掉后，企业关闭前置机A，人工将前置机A的批次信息文件拷贝到前置机B。</li><li>启动前置机B,检查日志信息是否正常启动，且缓存文件正常加载。</li><li>企业将交易切到前置机B。</li></ol><h3><span id="双机热备">双机热备</span></h3><p>双机热备特指基于高可用系统中的两台服务器的热备（或高可用），因两机高可用在国内使用较多，故得名双机热备，双机高可用按工作中的切换方式分为：主-备方式（Active-Standby方式）和双主机方式（Active-Active方式），主-备方式即指的是一台服务器处于某种业务的激活状态（即Active状态），另一台服务器处于该业务的备用状态（即Standby状态）。而双主机方式即指两种不同业务分别在两台服务器上互为主备状态（即Active-Standby和Standby-Active状态）。</p><p><img src="//guojielin.github.io/2019/03/05/保融前置机系统架构V-1/2749555-1G121151R5405.png" alt="2749555-1G121151R5405.png"></p><p>　　故障隔离，简单的讲，高可用（热备）就是一种利用故障点转移的方式来保障业务连续性。其业务的恢复不是在原服务器，而是在备用服务器。热备不具有修复故障服务器的功能，而只是将故障隔离。</p><p>新版本前置机不再存储批次信息到本地，将批次信息存储到保融后端，解决了前置机数据共享问题，因此支持双机热备方案。<br>企业可以同时部署多台保融前置机，通过负载均衡发送到前置机处理，同时前置机也通过负载均衡发送到保融后端服务。很好的解决了单点故障，同时也极大地提高了故障恢复(隔离)时间。</p><p><img src="//guojielin.github.io/2019/03/05/保融前置机系统架构V-1/2019-03-07-09-43-47.png" alt="2019-03-07-09-43-47.png"></p><h3><span id="保融后端服务集群">保融后端服务集群</span></h3><p>保融目前通过在多个机房部署服务，满足企业从不通机房进行网络通讯，提高了通讯可靠性。<br>前置机目前支持人工配置多个后端服务地址，同时通过负载均衡算法分配保融后端服务节点。</p><h2><span id="负载均衡">负载均衡</span></h2><p>目前前置机上采取加权轮询法，需要在前置机上配置地址集群各个服务的加权比重，在通过加权轮询算法获取后端服务地址。</p><h3><span id="加权轮询法">加权轮询法</span></h3><p>加权轮询法是在轮询法的基础上添加加权比重配置。添加该配置之后可以根据服务器的不同处理能力，给每个前置机配置的后台地址分配不同的权值，使其能够根据相应权值数的发送服务请求。<br>同时为了提高连接可靠性，在保融后端服务节点A不通的情况下，我们会将节点A禁用，只用网络通畅的其他节点进行负载均衡，这样在前置机配置了后端服务集群的情况下能够极大的提高可靠性，当保融后端服务节点A连通时，前置机也能自动恢复和保融后端服务节点A之间的连接，仍然能自动分配给节点A。</p><h3><span id="最快响应法">最快响应法</span></h3><p>最快响应在智能分配路由时起到了非常积极的作用。无论后台有多少可用节点，通过该算法都能智能的选择最快的节点。后续前置机可能会添加该算法进行更为智能的分配。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前置机 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统架构0.3</title>
      <link href="/2019/03/05/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84V0.3/"/>
      <url>/2019/03/05/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84V0.3/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1><span id="系统架构">系统架构</span></h1><h2><span id="背景">背景</span></h2><p>随着Internet的快速发展和业务量的不断提高，基于网络的数据访问流量迅速增长，同时许多企业的网站或接口都需要提供<strong>7*24</strong>小时不间断访问，任何服务中断都会直接或间接的造成商业损失，因此企业对于应用服务提出了高性能和高可靠性的要求。随着用户量和数据量的急速递增，传统的单机模式，不但成为性能瓶颈，也会存在单点故障，<strong>系统架构升级</strong>刻不容缓。</p><h2><span id="单机系统">单机系统</span></h2><p>企业对接时，一开始数据量并不大，前端系统和后端服务都只用部署1个即可。</p><p><img src="//guojielin.github.io/2019/03/05/系统架构V0.3/2019-03-07-17-58-17.png" alt="2019-03-07-17-58-17.png"></p><h2><span id="冷备">冷备</span></h2><p>一开始只有1个服务没有什么影响，但是随着服务长时间运行，会碰到服务升级，网络不通等情况，就会存在服务长时间无法访问。此时就非常需要添加一个备用服务器。<br>冷备技术，部署备用服务，在2台(或多台)服务器运行的时候，当正在提供服务的这台服务器出现故障后，人工手动切换到另一台服务器，保障系统的可以继续运行服务。</p><p><img src="//guojielin.github.io/2019/03/05/系统架构V0.3/2019-03-08-11-20-55.png" alt="2019-03-08-11-20-55.png"></p><p>虽然双机冷备能起到临时解决作用，但是服务器切换的时候难免需要人工处理时间，在人工处理时，服务往往是不可用的。<br>一般来说网络服务供应商和客户之前会有一份关于可用性的合同，其衡量标准即为SLA(Service Level Agreement,服务等级协议),该衡量标准同样也适用于企业服务。</p><table><thead><tr><th>可用时间(百分比)</th><th>不可用时间(每年)</th><th>不可用时间(每天)</th></tr></thead><tbody><tr><td>90%</td><td>36.5天</td><td>2.4小时</td></tr><tr><td>99%</td><td>3.65天</td><td>14分钟</td></tr><tr><td>99.9%</td><td>8.76小时</td><td>86秒</td></tr><tr><td>99.99%</td><td>52.6分</td><td>8.6秒</td></tr><tr><td>99.999%</td><td>5.25分</td><td>0.86秒</td></tr><tr><td>99.9999%</td><td>31.5秒</td><td>0.86秒</td></tr></tbody></table><p>一般来说，我们的观念里一个服务至少要做到99.9%才称为基本上可用，是合格性产品，否则基本很难被别人使用。理论上来说，作为一个正常人类，收到突发报警、能正确的分析出问题所在、找到正确的解决方案、并且<strong>正确实施</strong>的时间极限大概是<strong>两分钟</strong>[^1]。但是对于实际情况，人工处理效率远大于该极限值。一般人工发现问题并找到问题原因，最终到解决问题可能至少要20分钟以上。可以想象的出2个9(99%)、3个(99.9%)是基本可以靠运气搞定的。到3个9可以靠堆人(也就是3班倒之类的强制值班)。但是在信息时代，设备是不值钱的，人力才是真正的资源。为了达到4个9的SLA标准，不得不提到高可用。</p><h2><span id="热备">热备</span></h2><p>热备(高可用)特指基于高可用系统中的两台(或多台)服务器的热备。简单的讲，热备就是一种利用故障点转移的方式来保障业务连续性。其业务的恢复不是在原服务器，而是在备用服务器。热备不具有修复故障服务器的功能，而只是将故障隔离。</p><p><img src="//guojielin.github.io/2019/03/05/系统架构V0.3/2019-03-08-11-15-44.png" alt="2019-03-08-11-15-44.png"></p><p>当启用了热备以后，虽然避免了单机故障，但是同时引入了新的问题。前端系统如何决定请求发往哪个后端服务？这时候就要通过负载均衡对请求进行分发。</p><h2><span id="负载均衡">负载均衡</span></h2><p>负载均衡是建立在现有网络结构之上，提供一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。通常负载均衡有两方面的含义。</p><ol><li>单个重负载的运算分担到多台节点设备上做并行处理，每个节点设备处理结束后，将结果汇总，返回给用户，系统处理能力得到大幅度提高，这就是常说的集群（clustering）技术。</li><li>大量的并发访问或数据流量分担到多台节点设备上分别处理，减少用户等待响应的时间，这主要针对Web服务器、FTP服务器、企业关键应用服务器等网络应用。通常，负载均衡会根据网络的不同层次（网络七层）来划分。目前所用到的负载均衡技术通常在网络协议的的第4层(传输层)或第7层(应用层)处理的。</li></ol><h3><span id="作用">作用</span></h3><ol><li>解决并发压力，提高应用处理性能。</li><li>提供故障转移，实现高可用。</li><li>通过添加或减少服务器数量，提供网站伸缩性（扩展性）。</li><li>安全防护；（负载均衡设备上做一些过滤，黑白名单等处理）。</li></ol><h3><span id="解决方案">解决方案</span></h3><h4><span id="dns负载均衡">DNS负载均衡</span></h4><p>早期的负载均衡是通过DNS实现的，通过将一个域名指向多个IP，当请求通过DNS服务器，根据指定的负载均衡策略(如随机分配、轮询等算法)返回指定IP。这样做配置简单，扩展性强。但是这种方法有一个很大的缺点就是延时性问题，在做出调度策略改变以后，由于DNS各级节点的缓存并不会及时的在客户端生效，而且DNS负载的调度策略比较简单，无法满足业务需求。</p><h4><span id="硬件负载均衡">硬件负载均衡</span></h4><p>硬件负载均衡器也称为F5，是处于网络协议<strong>传输层</strong>的负载均衡解决方案，是直接在服务器和外部网络间安装负载均衡设备，由于专门的设备完成专门的任务，独立于操作系统，整体性能得到大量提高，加上多样化的负载均衡策略，智能化的流量管理，可达到最佳的负载均衡需求。</p><p><img src="//guojielin.github.io/2019/03/05/系统架构V0.3/2019-03-08-11-12-36.png" alt="2019-03-08-11-12-36.png"></p><p>负载均衡器的工作是转发报文，接收到请求时，修改数据包的目标地址，从而将包转发到指定的应用服务器。使用负载均衡器功能和性能都很不错，但是价格比较昂贵，且负载均衡器本身又会变为一个单点。虽然现在主流的负载均衡器也都支持主备容灾功能，但是理论上需要形成1+2(1主2备)才能实现真正的高可用，其中一台挂掉后依然还是1主1备，但是主要还是价格比较昂贵。</p><h4><span id="软件负载均衡">软件负载均衡</span></h4><p>由于硬件负载均衡虽然性能很好，但是非常昂贵，随着负载均衡的负载，基于软件的负载均衡方案脱颖而出，它的有点是费用低廉，实现功能强大。Nginx/LVS/HAProxy是目前使用最广泛的三种负载均衡软件。</p><h5><span id="nginx">Nginx</span></h5><p>Nignx是在应用层上实现的一个基于反向代理的软件。针对Http应用做了分流策略，通过Nginx解析Http头部将请求分发到配置的指定服务器。同时通过简单的配置即可实现后端服务集群配置，通过内置的负载均衡算法将请求分配到指定的服务。Nginx也支持部署集群，可以避免反向代理服务本身存在单点故障。然而Nginx最大的缺点之一就是仅支持HTTP、HTTPS、EMail等协议，适用范围较小。</p><blockquote><p>反向代理，在接收到前端请求后，根据负载均衡算法分配到其中一个后端地址，然后反向代理软件所在的服务器与后端服务器建立TCP连接。这种方式可以对前端的请求和后端的响应的数据进行任意修改，极大的提升了应用系统在网络层的灵活性。但同时，对性能的要求也增强了。</p></blockquote><p><img src="//guojielin.github.io/2019/03/05/系统架构V0.3/2019-03-08-11-12-03.png" alt="2019-03-08-11-12-03.png"></p><h5><span id="lvs">LVS</span></h5><p>LVS使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。LVS有三种模式，分别为NAT(网络地址转换)、TUN(隧道)、DR(直接路由)。</p><ol><li>NAT模式对数据包的IP和端口进行修改并转发。</li><li>TUN模式通过IP隧道(将IP数据报封装到IP数据报中的技术)对IP数据包再次封装并转发。</li><li>DR模式通过对Linux的内核参数进行一定的配置之后，通过修改请求的MAC地址将其转发到指定的后端服务，从而实现转发。</li></ol><p>因为它工作在传输层，因此比Nignx更为高效，也因此它不能和Nginx一样解析应用层数据包做动静分离，相比于Nginx的功能就显得没那么强大。</p><h5><span id="haproxy">HAProxy</span></h5><p>Haproxy是高可用代理软件，它是一种比较流行的开源软件，基于TCP(四层)/HTTP(七层)协议的负载均衡代理解决方案，可以在Linux、FreeBSD等平台下运行，常见于跨多个服务器，比如:web、应用程序、数据库、MQ消息队列、MC数据库等等。通过多个Haproxy服务来提高服务的性能和可靠性。HAProxy基于第四层负载均衡逻辑是通过转发到指定的服务IP和端口，类似于LVS-NAT模式。第七层负载均衡原理和Nginx类似。</p><h3><span id="负载均衡算法">负载均衡算法</span></h3><ol><li>轮询法<br>将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</li><li>随机法<br>通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，<br>其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</li><li>源地址哈希法<br>源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</li><li>加权轮询法<br>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</li><li>加权随机法<br>与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</li><li>最小连接数法<br>最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前<br>积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</li></ol><h3><span id="负载均衡容错">负载均衡容错</span></h3><p>负载均衡除了分配服务以外，容错机制也是必不可少的功能。容错机制通过自动侦测、自动切换和自动恢复3个阶段完成。</p><h4><span id="自动侦测">自动侦测</span></h4><p>通过判断服务节点的网络、负载等情况决定服务节点可用性。</p><ol><li>端口连通性<br>我们可以通过一个端口是否可连通作为节点是否可用的基本判断。</li><li>服务可用<br>在大多数情况，端口连通并不一定可以提供服务。因此为了提高容错率，我们需要考虑服务可用性。可以添加一个特定的接口，用于返回服务是否可用，返回的指标有很多，比如服务的负载情况，服务所在服务器的负载情况等。<ul><li>使用HTTP协议：可以判断HTTP的状态码，如每个节点都状态码为200时表示服务可用，状态码非200时服务不可用。</li><li>使用TCP协议：TCP并没有状态码，因此我们需要自定义的报文返回服务是否可用。</li></ul></li></ol><h4><span id="自动切换">自动切换</span></h4><p>当自动侦测到某节点不可用时，则需要根据规则进行容灾处理，比如将服务节点从可用节点移除，发送预警通知等。</p><h4><span id="自动恢复">自动恢复</span></h4><p>当侦测到服务可用时，可以自动进行注册到可用服务列表中。</p><h2><span id="参考文献">参考文献</span></h2><ol><li><a href="http://www.cnblogs.com/danbing/p/7459224.html" target="_blank" rel="noopener">负载均衡基础知识</a></li><li><a href="https://blog.csdn.net/github_37515779/article/details/79953788" target="_blank" rel="noopener">高并发解决方案之一 ——负载均衡</a></li><li><a href="https://www.jianshu.com/p/c91fe3f94e5c" target="_blank" rel="noopener">什么是负载均衡，为什么要做负载均衡？</a></li><li><a href="https://www.jianshu.com/p/b67af78f1088" target="_blank" rel="noopener">浅析负载均衡的6种算法，Ngnix的5种算法</a></li></ol><p>[^1]: 杨卫华. 高可用架构·硅谷篇（第4期）.</p>]]></content>
      
      
      <categories>
          
          <category> 系统架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> 系统架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志格式设计V0.3</title>
      <link href="/2019/03/04/%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F%E8%AE%BE%E8%AE%A1V0.3/"/>
      <url>/2019/03/04/%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F%E8%AE%BE%E8%AE%A1V0.3/</url>
      
        <content type="html"><![CDATA[<h2><span id="背景">背景</span></h2><p>原来日志存储到本地文件，主要为以下几种方式：</p><p>批量：<br><img src="https://img2018.cnblogs.com/blog/580757/201902/580757-20190213145444130-1957303063.png" alt="20190213145444.png"></p><blockquote><p>大多以模块拆分目录，送盘入库文件名为日志名，区分不同批次，便于人工查找。<br>通过StringBuilder保存某次的日志处理完成后同步一次写入日志，避免每次写文件的性能损耗，但是是同步保存日志。</p></blockquote><p>单笔：<br><img src="https://img2018.cnblogs.com/blog/580757/201902/580757-20190213145233911-400734701.png" alt="20190213145233.png"></p><blockquote><p>以业务类型拆分目录，通过Xsearch等工具搜索流水号进行查找，或者通过流水号查找会话id进行查找。<br>通过StringBuilder保存某次会话线程连续执行的日志，执行完异步保存一次，避免每次写文件的性能损耗。</p></blockquote><p>FTP2:<br><img src="https://img2018.cnblogs.com/blog/580757/201902/580757-20190213145103773-1786118938.png" alt="20190213145104.png"></p><blockquote><p>以模块拆分目录，时间戳+GUID防止日志名重复，通过批次号或流水号信息进行查找会话id，然后在通过会话id进行查询。<br>通过StringBuilder保存某次会话线程连续执行的日志，执行完保存一次，避免每次写文件的性能损耗。</p></blockquote><p>同步程序：<br><img src="https://img2018.cnblogs.com/blog/580757/201902/580757-20190213150252490-1367409030.png" alt="20190213150252.png"></p><blockquote><p>通过关键词查找到日志前面的日志id，通过日志id搜索肉眼查看日志。<br>每条日志直接写入队列，日志线程异步写入硬盘。</p></blockquote><p>批量，单笔，FTP2等程序每次日志写入通过约定的分隔符分隔日志，同步程序以异步的方式记录日志方式，通过日志id区分日志。</p><p>综上所述，我们原来的日志都是记录下来即可，并没有考虑如何统计，如何便于查找。且很多程序没有公共的日志模块，记录的格式风格都有所不同。</p><p>查找日志流程</p><pre class="mermaid">graph LR    根据险企号查找在哪台服务器-->到程序目录    到程序目录-->到模块目录指定日期下    到模块目录指定日期下--> 根据流水号查找</pre><h2><span id="存在的问题">存在的问题</span></h2><ol><li>日志或汇总异步保存或汇总同步保存，甚至逐条同步保存，实时性较低，且可能存在磁盘性能对程序处理速度造成负面影响。</li><li>日志格式凌乱，且没有格式化。造成无法统一解析并分析。</li><li>日志散落在各个服务器，无法汇总查看，查询较麻烦。</li><li>日志汇总保存存在以下情况，异步发送到系统B，保存一次日志，B系统响应后处理完成再保存，这中间需要人为清理日志。增加不必要的代码，增加了代码复杂性。可能存在日志没有即使记录的问题造成不知道是日志没记录还是代码执行到哪个逻辑卡住，检查问题造成了不必要的麻烦。</li></ol><h2><span id="目的">目的</span></h2><ol><li>日志格式统一并结构化。</li><li>日志可汇总收集。</li><li>日志异步记录，简化日志代码逻辑。</li></ol><h2><span id="解决了什么问题">解决了什么问题</span></h2><ol><li>通过日志格式化后，可以通过界面化工具进行筛选查找。</li><li>日志汇总收集后，查询日志无需跑到各个服务器上单独查找。且同一笔流水号或批次散落在不同服务器的日志也可以一次性筛选出来，方便日志分析。</li><li>通过格式化的日志可以更容易的进行性能分析，且将性能分析与具体程序业务逻辑解耦。</li></ol><h2><span id="解决方案">解决方案</span></h2><pre class="mermaid">graph LR    NLog-->文件    NLog-->数据库    文件-->Log2View    数据库-->Log2View    NLog--tcp/udp-->Log2View    NLog--其他-->Log2View</pre><ol><li>通过Nlog开源日志模块记录日志。(也可以是其他的如Log4Net、Serilog等日志模块)</li><li>将日志保存到文件、数据库或者通过网络传输汇总收集日志。</li><li>通过Log2View等(也可以是其他工具，或自行开发的工具)界面工具对结构化日志进行解析并展示。</li></ol><blockquote><p>经过测试发现通过tcp/udp发送到log2view，log4view直接显示的会偏少，可能是log4view本身接收处理有队列上西安（但是却没有配置），或者是其他原因。<br>经测试发现log4view读取数据库部分列不能显示，应该是log4view本身功能上的问题，或其他原因。</p></blockquote><h2><span id="名词解释">名词解释</span></h2><p>结合我们当前的业务模型，逻辑上将日志分为3个维度。网络层日志、服务层日志、业务日志。</p><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>“网络层”日志</td><td>这里所说的网络层日志并不是传统意义上的网络协议中的网络层，而是应用层对网络流的读写以及编码解码所作的工作。归并为“网络层”日志。</td></tr><tr><td>服务层日志</td><td>在“网络层”微服务调用的路由日志，该日志与“网路层”日志和业务日志区分。只含有服务、会话id等信息，而不包含业务的相关信息。</td></tr><tr><td>业务日志</td><td>业务逻辑处理的日志，包含业务上的流水号，以及业务处理信息</td></tr></tbody></table><blockquote><p>不同维度记录的日志字段不同。</p></blockquote><h2><span id="字段">字段</span></h2><h3><span id="网络层日志">“网络层”日志</span></h3><table><thead><tr><th>参数英文名</th><th>参数中文名</th><th>参数说明</th><th>是否可空</th></tr></thead><tbody><tr><td>Time</td><td>时间</td><td>日志的记录时间</td><td>否</td></tr><tr><td>LogLevel</td><td>日志等级</td><td>当前日志的等级</td><td>否</td></tr><tr><td>AppId</td><td>程序id</td><td>当前日志所在程序的唯一id，日志汇总时方便查找</td><td>是</td></tr><tr><td>Logger</td><td>日志名</td><td>可以是类名，也可以是自定义的一个名字，可用于筛选哪个模块的日志</td><td>否</td></tr><tr><td>Identity</td><td>请求身份码</td><td>每个连接有一个唯一的身份码</td><td>否</td></tr><tr><td>RequestId</td><td>会话ID</td><td>本次请求的唯一会话Id</td><td>是</td></tr><tr><td>Message</td><td>日志内容</td><td>记录下来的日志内容</td><td>否</td></tr><tr><td>Exception</td><td>异常信息</td><td>出现异常时代码调用的异常信息，包括堆栈信息，只有异常时才有</td><td>是</td></tr></tbody></table><ol><li>AppId<br>AppId为当前程序的程序唯一id，AppId可以确定为唯一的一个程序，以及该程序所在地址的信息。需要有个地方能为每个程序注册唯一id。<br>本地文件存储不需要记录AppId,通过网络发送或数据库存储需要记录Appid便于筛选。</li><li>Identity<br>当接收到一个客户端请求时，立即生成一个唯一的identity。通过identity能够确认到某一条连接。若为短链接，则每个会话都会有唯一的一个identity，若为长连接，同一条连接的Identity不会改变。因此identity用于区分哪条连接。</li></ol><blockquote><p>为了方便查找问题，每一条解析出来的报文都记录接收到的内容。</p></blockquote><h3><span id="服务层日志">服务层日志</span></h3><table><thead><tr><th>参数英文名</th><th>参数中文名</th><th>参数说明</th><th>是否可空</th></tr></thead><tbody><tr><td>Time</td><td>时间</td><td>日志的记录时间</td><td>否</td></tr><tr><td>LogLevel</td><td>日志等级</td><td>当前日志的等级</td><td>否</td></tr><tr><td>AppId</td><td>程序id</td><td>当前日志所在程序的唯一id，日志汇总时方便查找</td><td>是</td></tr><tr><td>Identity</td><td>请求身份码</td><td>每个连接有一个唯一的身份码</td><td>否</td></tr><tr><td>SourceId</td><td>源会话ID</td><td>原始请求的唯一会话Id,可用于关联原始请求的id，即来源id</td><td>是</td></tr><tr><td>RequestId</td><td>会话ID</td><td>本次请求的唯一会话Id</td><td>否</td></tr><tr><td>SourceServiceName</td><td>原始服务名</td><td>通过服务名决定服务的分配</td><td>否</td></tr><tr><td>SourceServiceId</td><td>原始服务Id</td><td>原始服务Id</td><td>否</td></tr><tr><td>TargetServiceName</td><td>目标服务名</td><td>通过服务名决定服务的分配</td><td>否</td></tr><tr><td>TargetServiceId</td><td>目标服务Id</td><td>目标服务Id</td><td>否</td></tr><tr><td>Message</td><td>日志内容</td><td>记录下来的日志内容</td><td>否</td></tr><tr><td>Exception</td><td>异常信息</td><td>出现异常时代码调用的异常信息，包括堆栈信息，只有异常时才有</td><td>是</td></tr><tr><td>Logger</td><td>日志名</td><td>可以是类名，也可以是自定义的一个名字，可用于筛选哪个模块的日志</td><td>否</td></tr></tbody></table><ol><li>SourceServiceId和TargetServiceId<br>服务id为每个服务在向服务中心注册的时候有会有一个唯一id。因此通过服务id就能确认到唯一的服务。通过服务id能够查找服务名，服务地址等信息。目前暂无服务id。</li><li>SourceServiceName和TargetServiceName<br>服务名为服务的标识，通过服务名进行服务的分配，目前通过配置文件的方式决定本地服务和远程服务，以及远程服务分发到地址。</li><li>SourceId<br>可以通过<code>SourceId</code>关联到整条服务链。</li><li>RequestId<br>通过<code>RequestId</code>用于查找本次服务会话。</li></ol><h3><span id="业务层日志">业务层日志</span></h3><table><thead><tr><th>参数英文名</th><th>参数中文名</th><th>参数说明</th><th>是否可空</th></tr></thead><tbody><tr><td>Time</td><td>时间</td><td>日志的记录时间</td><td>否</td></tr><tr><td>LogLevel</td><td>日志等级</td><td>当前日志的等级</td><td>否</td></tr><tr><td>AppId</td><td>程序id</td><td>当前日志所在程序的唯一id，日志汇总时方便查找</td><td>是</td></tr><tr><td>Logger</td><td>日志名</td><td>可以是类名，也可以是自定义的一个名字，可用于筛选哪个模块的日志</td><td>否</td></tr><tr><td>SourceId</td><td>源会话ID</td><td>原始请求的唯一会话Id,可用于关联原始请求的id，即来源id</td><td>是</td></tr><tr><td>RequestId</td><td>会话ID</td><td>本次请求的唯一会话Id</td><td>否</td></tr><tr><td>UniqueNo</td><td>唯一编号</td><td>业务需要用到的唯一编号，比如批次号或流水号等</td><td>是</td></tr><tr><td>Message</td><td>日志内容</td><td>记录下来的日志内容</td><td>否</td></tr><tr><td>Exception</td><td>异常信息</td><td>出现异常时代码调用的异常信息，包括堆栈信息，只有异常时才有</td><td>是</td></tr></tbody></table><ol><li>Logger<br>可用于业务的分类，不同的业务日志存储到不同文件夹中。若通过网络统一收集，则可以通过<code>Logger</code>用于筛选。</li><li>UniqueNo<br>存放业务上的唯一编号，比如批次号或流水号，通过批次号和流水号查找会话id，通过会话id关联某次会话请求，通过源会话id关联某次会话请求的完整处理流程。</li><li>对于单笔业务目前不会关联上一个节点(前置机)的请求。没有<code>SourceId</code>，只有当前的会话id<code>RequestId</code>。</li></ol><h3><span id="其他参数">其他参数</span></h3><p>其他可选参数，便于筛选日志。</p><table><thead><tr><th>参数英文名</th><th>参数中文名</th><th>参数说明</th><th>是否可空</th></tr></thead><tbody><tr><td>Source</td><td>来源</td><td>来源ip地址</td><td>否</td></tr><tr><td>Assembly</td><td>程序集</td><td>日志调用所在程序集</td><td>否</td></tr><tr><td>Class</td><td>类</td><td>日志所在类</td><td>否</td></tr><tr><td>Method</td><td>方法</td><td>日志所在方法</td><td>否</td></tr></tbody></table><h2><span id="日志等级定义">日志等级定义</span></h2><p>什么样的日志归属于什么样的等级，需要明确的定义。</p><h3><span id="trace">Trace</span></h3><p>trace是最低一级的等级。包含有最详细的日志。在大多数情况下这种日志不需要使用。但是在关键节点的日志分析上起到了决定性作用。<br>包括了每个可能出现问题的步骤点的日志。该日志量太大，因此用于实时查看日志用，避免持久化。</p><h3><span id="debug">Debug</span></h3><p>比Info更为详细的日志，甚至包括一些逻辑性判断结果，关键数据记录等，主要是用于开发或运维人员分析问题用。</p><h3><span id="info">Info</span></h3><p>正常业务逻辑日志，只需要记录关键性步骤，日志量不会很大，但是能体现主体流程信息。</p><h3><span id="warn">Warn</span></h3><p>在预期内可能会出现的错误，一般是在<code>catch</code>代码块中捕获且可能发生的异常。但是不影响业务处理，且即使忽略也不会造成影响的日志信息。主要是用于人工排查错误时看的异常日志。</p><h3><span id="error">Error</span></h3><p>未在预期内出现的错误，一般是在<code>catch</code>代码块中捕获且不希望发生或不在预期内的异常。但是不会造成整个程序甚至服务器收到影响的错误。</p><h3><span id="fatal">Fatal</span></h3><p>fatal是致命的错误，可以导致程序挂掉，更为严重甚至会影响整个服务器。理论上程序需要直接挂掉而避免导致服务器收到影响。</p><ol><li>线程执行中未捕获的异常。<br>这些异常会导致异常向外抛出造成程序崩溃，可以通过记录在windows日志中，在程序中如果可以直接记录更为直观。</li><li>OOM等异常。出现OutOfMemoryException异常时，表示内存满了或其他原因造成内存溢出的严重错误。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础设施 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 格式规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/03/hello-world/"/>
      <url>/2019/03/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><p><img src="//guojielin.github.io/2019/03/03/hello-world/pasted-0.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> Get Start </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Get Start </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
